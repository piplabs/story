// Code generated - DO NOT EDIT.
// This file is a generated binding and any manual changes will be lost.

package bindings

import (
	"errors"
	"math/big"
	"strings"

	ethereum "github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/event"
)

// Reference imports to suppress errors if they are not otherwise used.
var (
	_ = errors.New
	_ = big.NewInt
	_ = strings.NewReader
	_ = ethereum.NotFound
	_ = bind.Bind
	_ = common.Big1
	_ = types.BloomLookup
	_ = event.NewSubscription
	_ = abi.ConvertType
)

// IIPTokenStakingRedelegateParams is an auto generated low-level Go binding around an user-defined struct.
type IIPTokenStakingRedelegateParams struct {
	DelegatorUncmpPubkey  []byte
	ValidatorCmpSrcPubkey []byte
	ValidatorCmpDstPubkey []byte
	Amount                *big.Int
}

// IPTokenStakingMetaData contains all meta data concerning the IPTokenStaking contract.
var IPTokenStakingMetaData = &bind.MetaData{
	ABI: "[{\"type\":\"constructor\",\"inputs\":[{\"name\":\"stakingRounding\",\"type\":\"uint256\",\"internalType\":\"uint256\"},{\"name\":\"defaultCommissionRate\",\"type\":\"uint32\",\"internalType\":\"uint32\"},{\"name\":\"defaultMaxCommissionRate\",\"type\":\"uint32\",\"internalType\":\"uint32\"},{\"name\":\"defaultMaxCommissionChangeRate\",\"type\":\"uint32\",\"internalType\":\"uint32\"}],\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"DEFAULT_COMMISSION_RATE\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint32\",\"internalType\":\"uint32\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"DEFAULT_MAX_COMMISSION_CHANGE_RATE\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint32\",\"internalType\":\"uint32\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"DEFAULT_MAX_COMMISSION_RATE\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint32\",\"internalType\":\"uint32\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"STAKE_ROUNDING\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\",\"internalType\":\"uint256\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"UPGRADE_INTERFACE_VERSION\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"string\",\"internalType\":\"string\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"acceptOwnership\",\"inputs\":[],\"outputs\":[],\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"addOperator\",\"inputs\":[{\"name\":\"uncmpPubkey\",\"type\":\"bytes\",\"internalType\":\"bytes\"},{\"name\":\"operator\",\"type\":\"address\",\"internalType\":\"address\"}],\"outputs\":[],\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"createValidator\",\"inputs\":[{\"name\":\"validatorUncmpPubkey\",\"type\":\"bytes\",\"internalType\":\"bytes\"},{\"name\":\"moniker\",\"type\":\"string\",\"internalType\":\"string\"},{\"name\":\"commissionRate\",\"type\":\"uint32\",\"internalType\":\"uint32\"},{\"name\":\"maxCommissionRate\",\"type\":\"uint32\",\"internalType\":\"uint32\"},{\"name\":\"maxCommissionChangeRate\",\"type\":\"uint32\",\"internalType\":\"uint32\"}],\"outputs\":[],\"stateMutability\":\"payable\"},{\"type\":\"function\",\"name\":\"createValidatorOnBehalf\",\"inputs\":[{\"name\":\"validatorUncmpPubkey\",\"type\":\"bytes\",\"internalType\":\"bytes\"}],\"outputs\":[],\"stateMutability\":\"payable\"},{\"type\":\"function\",\"name\":\"delegatorTotalStakes\",\"inputs\":[{\"name\":\"delegatorCmpPubkey\",\"type\":\"bytes\",\"internalType\":\"bytes\"}],\"outputs\":[{\"name\":\"stakedAmount\",\"type\":\"uint256\",\"internalType\":\"uint256\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"delegatorValidatorStakes\",\"inputs\":[{\"name\":\"delegatorCmpPubkey\",\"type\":\"bytes\",\"internalType\":\"bytes\"},{\"name\":\"validatorCmpPubkey\",\"type\":\"bytes\",\"internalType\":\"bytes\"}],\"outputs\":[{\"name\":\"stakedAmount\",\"type\":\"uint256\",\"internalType\":\"uint256\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"getOperators\",\"inputs\":[{\"name\":\"pubkey\",\"type\":\"bytes\",\"internalType\":\"bytes\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address[]\",\"internalType\":\"address[]\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"initialize\",\"inputs\":[{\"name\":\"accessManager\",\"type\":\"address\",\"internalType\":\"address\"},{\"name\":\"_minStakeAmount\",\"type\":\"uint256\",\"internalType\":\"uint256\"},{\"name\":\"_minUnstakeAmount\",\"type\":\"uint256\",\"internalType\":\"uint256\"},{\"name\":\"_minRedelegateAmount\",\"type\":\"uint256\",\"internalType\":\"uint256\"},{\"name\":\"_withdrawalAddressChangeInterval\",\"type\":\"uint256\",\"internalType\":\"uint256\"}],\"outputs\":[],\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"minRedelegateAmount\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\",\"internalType\":\"uint256\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"minStakeAmount\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\",\"internalType\":\"uint256\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"minUnstakeAmount\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\",\"internalType\":\"uint256\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"owner\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\",\"internalType\":\"address\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"pendingOwner\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\",\"internalType\":\"address\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"proxiableUUID\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\",\"internalType\":\"bytes32\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"redelegate\",\"inputs\":[{\"name\":\"p\",\"type\":\"tuple\",\"internalType\":\"structIIPTokenStaking.RedelegateParams\",\"components\":[{\"name\":\"delegatorUncmpPubkey\",\"type\":\"bytes\",\"internalType\":\"bytes\"},{\"name\":\"validatorCmpSrcPubkey\",\"type\":\"bytes\",\"internalType\":\"bytes\"},{\"name\":\"validatorCmpDstPubkey\",\"type\":\"bytes\",\"internalType\":\"bytes\"},{\"name\":\"amount\",\"type\":\"uint256\",\"internalType\":\"uint256\"}]}],\"outputs\":[],\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"redelegateOnBehalf\",\"inputs\":[{\"name\":\"p\",\"type\":\"tuple\",\"internalType\":\"structIIPTokenStaking.RedelegateParams\",\"components\":[{\"name\":\"delegatorUncmpPubkey\",\"type\":\"bytes\",\"internalType\":\"bytes\"},{\"name\":\"validatorCmpSrcPubkey\",\"type\":\"bytes\",\"internalType\":\"bytes\"},{\"name\":\"validatorCmpDstPubkey\",\"type\":\"bytes\",\"internalType\":\"bytes\"},{\"name\":\"amount\",\"type\":\"uint256\",\"internalType\":\"uint256\"}]}],\"outputs\":[],\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"removeOperator\",\"inputs\":[{\"name\":\"uncmpPubkey\",\"type\":\"bytes\",\"internalType\":\"bytes\"},{\"name\":\"operator\",\"type\":\"address\",\"internalType\":\"address\"}],\"outputs\":[],\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"renounceOwnership\",\"inputs\":[],\"outputs\":[],\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"roundedStakeAmount\",\"inputs\":[{\"name\":\"rawAmount\",\"type\":\"uint256\",\"internalType\":\"uint256\"}],\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\",\"internalType\":\"uint256\"},{\"name\":\"remainder\",\"type\":\"uint256\",\"internalType\":\"uint256\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"setMinRedelegateAmount\",\"inputs\":[{\"name\":\"newMinRedelegateAmount\",\"type\":\"uint256\",\"internalType\":\"uint256\"}],\"outputs\":[],\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"setMinStakeAmount\",\"inputs\":[{\"name\":\"newMinStakeAmount\",\"type\":\"uint256\",\"internalType\":\"uint256\"}],\"outputs\":[],\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"setMinUnstakeAmount\",\"inputs\":[{\"name\":\"newMinUnstakeAmount\",\"type\":\"uint256\",\"internalType\":\"uint256\"}],\"outputs\":[],\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"setWithdrawalAddress\",\"inputs\":[{\"name\":\"delegatorUncmpPubkey\",\"type\":\"bytes\",\"internalType\":\"bytes\"},{\"name\":\"newWithdrawalAddress\",\"type\":\"address\",\"internalType\":\"address\"}],\"outputs\":[],\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"setWithdrawalAddressChangeInterval\",\"inputs\":[{\"name\":\"newWithdrawalAddressChangeInterval\",\"type\":\"uint256\",\"internalType\":\"uint256\"}],\"outputs\":[],\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"stake\",\"inputs\":[{\"name\":\"delegatorUncmpPubkey\",\"type\":\"bytes\",\"internalType\":\"bytes\"},{\"name\":\"validatorCmpPubkey\",\"type\":\"bytes\",\"internalType\":\"bytes\"}],\"outputs\":[],\"stateMutability\":\"payable\"},{\"type\":\"function\",\"name\":\"stakeOnBehalf\",\"inputs\":[{\"name\":\"delegatorUncmpPubkey\",\"type\":\"bytes\",\"internalType\":\"bytes\"},{\"name\":\"validatorCmpPubkey\",\"type\":\"bytes\",\"internalType\":\"bytes\"}],\"outputs\":[],\"stateMutability\":\"payable\"},{\"type\":\"function\",\"name\":\"transferOwnership\",\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\",\"internalType\":\"address\"}],\"outputs\":[],\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"unstake\",\"inputs\":[{\"name\":\"delegatorUncmpPubkey\",\"type\":\"bytes\",\"internalType\":\"bytes\"},{\"name\":\"validatorCmpPubkey\",\"type\":\"bytes\",\"internalType\":\"bytes\"},{\"name\":\"amount\",\"type\":\"uint256\",\"internalType\":\"uint256\"}],\"outputs\":[],\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"unstakeOnBehalf\",\"inputs\":[{\"name\":\"delegatorCmpPubkey\",\"type\":\"bytes\",\"internalType\":\"bytes\"},{\"name\":\"validatorCmpPubkey\",\"type\":\"bytes\",\"internalType\":\"bytes\"},{\"name\":\"amount\",\"type\":\"uint256\",\"internalType\":\"uint256\"}],\"outputs\":[],\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"upgradeToAndCall\",\"inputs\":[{\"name\":\"newImplementation\",\"type\":\"address\",\"internalType\":\"address\"},{\"name\":\"data\",\"type\":\"bytes\",\"internalType\":\"bytes\"}],\"outputs\":[],\"stateMutability\":\"payable\"},{\"type\":\"function\",\"name\":\"validatorMetadata\",\"inputs\":[{\"name\":\"validatorCmpPubkey\",\"type\":\"bytes\",\"internalType\":\"bytes\"}],\"outputs\":[{\"name\":\"exists\",\"type\":\"bool\",\"internalType\":\"bool\"},{\"name\":\"moniker\",\"type\":\"string\",\"internalType\":\"string\"},{\"name\":\"totalStake\",\"type\":\"uint256\",\"internalType\":\"uint256\"},{\"name\":\"commissionRate\",\"type\":\"uint32\",\"internalType\":\"uint32\"},{\"name\":\"maxCommissionRate\",\"type\":\"uint32\",\"internalType\":\"uint32\"},{\"name\":\"maxCommissionChangeRate\",\"type\":\"uint32\",\"internalType\":\"uint32\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"withdrawalAddressChange\",\"inputs\":[{\"name\":\"delegatorCmpPubkey\",\"type\":\"bytes\",\"internalType\":\"bytes\"}],\"outputs\":[{\"name\":\"lastChange\",\"type\":\"uint256\",\"internalType\":\"uint256\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"withdrawalAddressChangeInterval\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\",\"internalType\":\"uint256\"}],\"stateMutability\":\"view\"},{\"type\":\"event\",\"name\":\"CreateValidator\",\"inputs\":[{\"name\":\"validatorUncmpPubkey\",\"type\":\"bytes\",\"indexed\":false,\"internalType\":\"bytes\"},{\"name\":\"validatorCmpPubkey\",\"type\":\"bytes\",\"indexed\":false,\"internalType\":\"bytes\"},{\"name\":\"moniker\",\"type\":\"string\",\"indexed\":false,\"internalType\":\"string\"},{\"name\":\"stakeAmount\",\"type\":\"uint256\",\"indexed\":false,\"internalType\":\"uint256\"},{\"name\":\"commissionRate\",\"type\":\"uint32\",\"indexed\":false,\"internalType\":\"uint32\"},{\"name\":\"maxCommissionRate\",\"type\":\"uint32\",\"indexed\":false,\"internalType\":\"uint32\"},{\"name\":\"maxCommissionChangeRate\",\"type\":\"uint32\",\"indexed\":false,\"internalType\":\"uint32\"}],\"anonymous\":false},{\"type\":\"event\",\"name\":\"Deposit\",\"inputs\":[{\"name\":\"delegatorUncmpPubkey\",\"type\":\"bytes\",\"indexed\":false,\"internalType\":\"bytes\"},{\"name\":\"delegatorCmpPubkey\",\"type\":\"bytes\",\"indexed\":false,\"internalType\":\"bytes\"},{\"name\":\"validatorCmpPubkey\",\"type\":\"bytes\",\"indexed\":false,\"internalType\":\"bytes\"},{\"name\":\"amount\",\"type\":\"uint256\",\"indexed\":false,\"internalType\":\"uint256\"}],\"anonymous\":false},{\"type\":\"event\",\"name\":\"Initialized\",\"inputs\":[{\"name\":\"version\",\"type\":\"uint64\",\"indexed\":false,\"internalType\":\"uint64\"}],\"anonymous\":false},{\"type\":\"event\",\"name\":\"MinRedelegateAmountSet\",\"inputs\":[{\"name\":\"minRedelegateAmount\",\"type\":\"uint256\",\"indexed\":false,\"internalType\":\"uint256\"}],\"anonymous\":false},{\"type\":\"event\",\"name\":\"MinStakeAmountSet\",\"inputs\":[{\"name\":\"minStakeAmount\",\"type\":\"uint256\",\"indexed\":false,\"internalType\":\"uint256\"}],\"anonymous\":false},{\"type\":\"event\",\"name\":\"MinUnstakeAmountSet\",\"inputs\":[{\"name\":\"minUnstakeAmount\",\"type\":\"uint256\",\"indexed\":false,\"internalType\":\"uint256\"}],\"anonymous\":false},{\"type\":\"event\",\"name\":\"OwnershipTransferStarted\",\"inputs\":[{\"name\":\"previousOwner\",\"type\":\"address\",\"indexed\":true,\"internalType\":\"address\"},{\"name\":\"newOwner\",\"type\":\"address\",\"indexed\":true,\"internalType\":\"address\"}],\"anonymous\":false},{\"type\":\"event\",\"name\":\"OwnershipTransferred\",\"inputs\":[{\"name\":\"previousOwner\",\"type\":\"address\",\"indexed\":true,\"internalType\":\"address\"},{\"name\":\"newOwner\",\"type\":\"address\",\"indexed\":true,\"internalType\":\"address\"}],\"anonymous\":false},{\"type\":\"event\",\"name\":\"Redelegate\",\"inputs\":[{\"name\":\"delegatorCmpPubkey\",\"type\":\"bytes\",\"indexed\":false,\"internalType\":\"bytes\"},{\"name\":\"validatorSrcPubkey\",\"type\":\"bytes\",\"indexed\":false,\"internalType\":\"bytes\"},{\"name\":\"validatorDstPubkey\",\"type\":\"bytes\",\"indexed\":false,\"internalType\":\"bytes\"},{\"name\":\"amount\",\"type\":\"uint256\",\"indexed\":false,\"internalType\":\"uint256\"}],\"anonymous\":false},{\"type\":\"event\",\"name\":\"SetWithdrawalAddress\",\"inputs\":[{\"name\":\"delegatorCmpPubkey\",\"type\":\"bytes\",\"indexed\":false,\"internalType\":\"bytes\"},{\"name\":\"executionAddress\",\"type\":\"bytes32\",\"indexed\":false,\"internalType\":\"bytes32\"}],\"anonymous\":false},{\"type\":\"event\",\"name\":\"Upgraded\",\"inputs\":[{\"name\":\"implementation\",\"type\":\"address\",\"indexed\":true,\"internalType\":\"address\"}],\"anonymous\":false},{\"type\":\"event\",\"name\":\"Withdraw\",\"inputs\":[{\"name\":\"delegatorCmpPubkey\",\"type\":\"bytes\",\"indexed\":false,\"internalType\":\"bytes\"},{\"name\":\"validatorCmpPubkey\",\"type\":\"bytes\",\"indexed\":false,\"internalType\":\"bytes\"},{\"name\":\"amount\",\"type\":\"uint256\",\"indexed\":false,\"internalType\":\"uint256\"}],\"anonymous\":false},{\"type\":\"event\",\"name\":\"WithdrawalAddressChangeIntervalSet\",\"inputs\":[{\"name\":\"newInterval\",\"type\":\"uint256\",\"indexed\":false,\"internalType\":\"uint256\"}],\"anonymous\":false},{\"type\":\"error\",\"name\":\"AddressEmptyCode\",\"inputs\":[{\"name\":\"target\",\"type\":\"address\",\"internalType\":\"address\"}]},{\"type\":\"error\",\"name\":\"ERC1967InvalidImplementation\",\"inputs\":[{\"name\":\"implementation\",\"type\":\"address\",\"internalType\":\"address\"}]},{\"type\":\"error\",\"name\":\"ERC1967NonPayable\",\"inputs\":[]},{\"type\":\"error\",\"name\":\"FailedInnerCall\",\"inputs\":[]},{\"type\":\"error\",\"name\":\"InvalidInitialization\",\"inputs\":[]},{\"type\":\"error\",\"name\":\"NotInitializing\",\"inputs\":[]},{\"type\":\"error\",\"name\":\"OwnableInvalidOwner\",\"inputs\":[{\"name\":\"owner\",\"type\":\"address\",\"internalType\":\"address\"}]},{\"type\":\"error\",\"name\":\"OwnableUnauthorizedAccount\",\"inputs\":[{\"name\":\"account\",\"type\":\"address\",\"internalType\":\"address\"}]},{\"type\":\"error\",\"name\":\"ReentrancyGuardReentrantCall\",\"inputs\":[]},{\"type\":\"error\",\"name\":\"UUPSUnauthorizedCallContext\",\"inputs\":[]},{\"type\":\"error\",\"name\":\"UUPSUnsupportedProxiableUUID\",\"inputs\":[{\"name\":\"slot\",\"type\":\"bytes32\",\"internalType\":\"bytes32\"}]}]",
	Bin: "0x61012034620002ca57601f62003f1238819003918201601f19168301916001600160401b039182841185851017620002cf578160809286926040968752833981010312620002ca578251926200005860208201620002e5565b6200007360606200006b868501620002e5565b9301620002e5565b913060805261010095865263ffffffff90818316612710938482116200027f5760a0528383831691821015918262000273575b5050156200021a5760c052821611620001c15760e0527ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a009081549060ff82851c16620001b05780808316036200016b575b50505051613bfa9182620002f88339608051828181610a4a0152610c21015260a0518281816109b10152611982015260c05182818161084d015261098f015260e05182818161096d0152611f000152518181816119be015281816126180152818161329c0152818161344401526135380152f35b6001600160401b0319909116811790915581519081527fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d290602090a1388080620000f7565b835163f92ee8a960e01b8152600490fd5b825162461bcd60e51b815260206004820152603a602482015260008051602062003ef283398151915260448201527f6d617820636f6d6d697373696f6e206368616e676520726174650000000000006064820152608490fd5b855162461bcd60e51b8152602060048201526033602482015260008051602062003ef283398151915260448201527f6d617820636f6d6d697373696f6e2072617465000000000000000000000000006064820152608490fd5b111590508338620000a6565b875162461bcd60e51b815260206004820152602f602482015260008051602062003ef283398151915260448201526e636f6d6d697373696f6e207261746560881b6064820152608490fd5b600080fd5b634e487b7160e01b600052604160045260246000fd5b519063ffffffff82168203620002ca5756fe6080604052600436101561001257600080fd5b60003560e01c8063057b929614610277578063060ceab01461027257806317e42e121461026d5780632d1e973e146102685780632ebc60341461026357806339ec4df91461025e57806348903e38146102595780634f1ef2861461025457806352d1902d1461024f57806353972c2a1461024a57806357067503146102455780635a69825d146102405780635d5ab9681461023b5780636ea3a22814610236578063715018a614610231578063787f82c81461022c57806379ba5097146102275780637b6e842c1461022257806383dffd6f1461021d57806386eec4a1146102185780638d3e1e41146102135780638da5cb5b1461020e5780638f37ec19146102095780639855c8b514610204578063a1cb1846146101ff578063ad3cb1cc146101fa578063b8db983e146101f5578063bda16b15146101f0578063c24ae586146101eb578063d2e1f5b8146101e6578063e30c3978146101e1578063eb4af045146101dc578063eee5cead146101d7578063f1887684146101d2578063f2fde38b146101cd578063f92ad219146101c8578063fc2e5932146101c35763fc56c2a2146101be57600080fd5b611ee3565b611de5565b611ba9565b611adc565b611abe565b611a9a565b611a76565b611a23565b6119f9565b6119e1565b6119a6565b611965565b611903565b611844565b611820565b6117b4565b611761565b6116d6565b611480565b611384565b61127b565b6111f3565b611061565b610f96565b610f72565b610e6e565b610e01565b610de9565b610ca3565b610bf9565b6109fc565b6108be565b610871565b610830565b6107c7565b610491565b610473565b610322565b9181601f840112156102aa5782359167ffffffffffffffff83116102aa57602083818601950101116102aa57565b600080fd5b6004359073ffffffffffffffffffffffffffffffffffffffff821682036102aa57565b60406003198201126102aa576004359067ffffffffffffffff82116102aa576102fd9160040161027c565b909160243573ffffffffffffffffffffffffffffffffffffffff811681036102aa5790565b346102aa57610330366102d2565b9061033d60418214611f24565b801561046e576103db6103d66103d18561039e7f04000000000000000000000000000000000000000000000000000000000000007fff000000000000000000000000000000000000000000000000000000000000006103e399351614611fde565b73ffffffffffffffffffffffffffffffffffffffff946103ca33876103c3848661271a565b1614612069565b369161066b565b6127bf565b6106e3565b9116906136f0565b156103ea57005b60846040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602760248201527f4950546f6b656e5374616b696e673a204f70657261746f7220616c726561647960448201527f20657869737473000000000000000000000000000000000000000000000000006064820152fd5b611faf565b346102aa5760006003193601126102aa576020600354604051908152f35b346102aa5761049f366102d2565b906104ac60418214611f24565b801561046e5761050d6103d66103d18561039e7f04000000000000000000000000000000000000000000000000000000000000007fff0000000000000000000000000000000000000000000000000000000000000061051599351614611fde565b9116906137f8565b1561051c57005b60846040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602260248201527f4950546f6b656e5374616b696e673a204f70657261746f72206e6f7420666f7560448201527f6e640000000000000000000000000000000000000000000000000000000000006064820152fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040810190811067ffffffffffffffff8211176105eb57604052565b6105a0565b90601f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0910116810190811067ffffffffffffffff8211176105eb57604052565b67ffffffffffffffff81116105eb57601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01660200190565b92919261067782610631565b9161068560405193846105f0565b8294818452818301116102aa578281602093846000960137010152565b9080601f830112156102aa578160206106bd9335910161066b565b90565b60005b8381106106d35750506000910152565b81810151838201526020016106c3565b60206106fc9181604051938285809451938492016106c0565b8101600781520301902090565b60206107229181604051938285809451938492016106c0565b8101600681520301902090565b60206107489181604051938285809451938492016106c0565b8101600581520301902090565b602061076e9181604051938285809451938492016106c0565b8101600881520301902090565b60206107949181604051938285809451938492016106c0565b8101600481520301902090565b6020906107bb9282604051948386809551938492016106c0565b82019081520301902090565b346102aa5760406003193601126102aa5767ffffffffffffffff6004358181116102aa576107f99036906004016106a2565b906024359081116102aa5760209161082161081b6108279336906004016106a2565b91610709565b906107a1565b54604051908152f35b346102aa5760006003193601126102aa57602060405163ffffffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b346102aa5760006003193601126102aa576020600154604051908152f35b60206003198201126102aa576004359067ffffffffffffffff82116102aa576108ba9160040161027c565b9091565b6108c73661088f565b906108d460418314611f24565b811561046e576109d69161092c7f04000000000000000000000000000000000000000000000000000000000000007fff0000000000000000000000000000000000000000000000000000000000000084351614611fde565b6109346128f6565b60405191610941836105cf565b600983527f76616c696461746f72000000000000000000000000000000000000000000000060208401527f0000000000000000000000000000000000000000000000000000000000000000927f0000000000000000000000000000000000000000000000000000000000000000927f000000000000000000000000000000000000000000000000000000000000000092612c3c565b60017f9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f0055005b60406003193601126102aa57610a106102af565b60243567ffffffffffffffff81116102aa57610a309036906004016106a2565b9073ffffffffffffffffffffffffffffffffffffffff91827f000000000000000000000000000000000000000000000000000000000000000016803014908115610bcb575b50610ba1576020600493610a87613254565b604051948580927f52d1902d00000000000000000000000000000000000000000000000000000000825286165afa60009381610b70575b50610b0a576040517f4c9c8ce300000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff83166004820152602490fd5b907f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc8303610b3e57610b3c9250613998565b005b6040517faa1d49a400000000000000000000000000000000000000000000000000000000815260048101849052602490fd5b610b9391945060203d602011610b9a575b610b8b81836105f0565b810190612e7d565b9238610abe565b503d610b81565b60046040517fe07c8dba000000000000000000000000000000000000000000000000000000008152fd5b9050837f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5416141538610a75565b346102aa5760006003193601126102aa5773ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000163003610ba15760206040517f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc8152f35b600319906020828201126102aa576004359167ffffffffffffffff83116102aa57826080920301126102aa5760040190565b346102aa57610cb136610c71565b610cbb81806120f4565b610cca60418294939414611f24565b1561046e57610d1e7f04000000000000000000000000000000000000000000000000000000000000007fff000000000000000000000000000000000000000000000000000000000000008094351614611fde565b610d2b60208201826120f4565b90610d3860218314611f24565b811561046e57610d88610d8f9282610d83610b3c9760ff9535167f02000000000000000000000000000000000000000000000000000000000000008114908115610d94575b50611fde565b612145565b5416612190565b61221b565b7f030000000000000000000000000000000000000000000000000000000000000091501438610d7d565b60206003198201126102aa576004359067ffffffffffffffff82116102aa576106bd916004016106a2565b346102aa576020610827610dfc36610dbe565b61072f565b346102aa5760006003193601126102aa576020600254604051908152f35b60606003198201126102aa5767ffffffffffffffff916004358381116102aa5782610e4c9160040161027c565b939093926024359182116102aa57610e669160040161027c565b909160443590565b346102aa57610e7c36610e1f565b92610e8c60418294939414611f24565b801561046e577fff0000000000000000000000000000000000000000000000000000000000000094610ee27f04000000000000000000000000000000000000000000000000000000000000008783351614611fde565b610f053373ffffffffffffffffffffffffffffffffffffffff6103c3858561271a565b610f1160218514611f24565b831561046e57610f51610b3c968435167f02000000000000000000000000000000000000000000000000000000000000008114908115610d945750611fde565b610f6d610f68610f618686612145565b5460ff1690565b612190565b6122ea565b346102aa5760206003193601126102aa57610f8b613254565b610b3c600435613294565b346102aa5760008060031936011261105e57610fb0613254565b8073ffffffffffffffffffffffffffffffffffffffff7fffffffffffffffffffffffff00000000000000000000000000000000000000007f237e158222e3e6968b72b9db0d8043aacf074ad9f650f0d1606b4d82ee432c008181541690557f9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c19930080549182169055167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08280a380f35b80fd5b346102aa5761106f366102d2565b9161107c60418314611f24565b811561046e576103d1816110d77f04000000000000000000000000000000000000000000000000000000000000007fff000000000000000000000000000000000000000000000000000000000000006110fc95351614611fde565b73ffffffffffffffffffffffffffffffffffffffff936103ca33866103c3848661271a565b916111068361072f565b541561116f5761116a8361115161114a6111407f9f7f04f688298f474ed4c786abb29e0ca0173d70516d55d9eac515609b45fbca97610755565b5460035490612346565b4211612353565b4261115b82610755565b556040519384931690836123de565b0390a1005b60846040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602960248201527f4950546f6b656e5374616b696e673a2044656c656761746f72206d757374206860448201527f617665207374616b6500000000000000000000000000000000000000000000006064820152fd5b346102aa5760006003193601126102aa573373ffffffffffffffffffffffffffffffffffffffff7f237e158222e3e6968b72b9db0d8043aacf074ad9f650f0d1606b4d82ee432c0054160361124b57610b3c33613388565b60246040517f118cdaa7000000000000000000000000000000000000000000000000000000008152336004820152fd5b346102aa5761128936610c71565b61129381806120f4565b91906112a160418414611f24565b821561046e5761131a9073ffffffffffffffffffffffffffffffffffffffff6103c37fff00000000000000000000000000000000000000000000000000000000000000956113137f04000000000000000000000000000000000000000000000000000000000000008886351614611fde565b339361271a565b61132760208201826120f4565b9061133460218314611f24565b811561046e57610f6161137f9282610d83610b3c97610f689535167f02000000000000000000000000000000000000000000000000000000000000008114908115610d945750611fde565b6123fa565b346102aa5761139b6113953661088f565b9061215e565b60405190819080548084526020809401908192600052846000209060005b868282106114255786866113cf828803836105f0565b604051928392818401908285525180915260408401929160005b8281106113f857505050500390f35b835173ffffffffffffffffffffffffffffffffffffffff16855286955093810193928101926001016113e9565b8354855290930192600192830192016113b9565b60406003198201126102aa5767ffffffffffffffff916004358381116102aa57826114669160040161027c565b939093926024359182116102aa576108ba9160040161027c565b61148936611439565b9161149660418214611f24565b801561046e577fff00000000000000000000000000000000000000000000000000000000000000936114ec7f04000000000000000000000000000000000000000000000000000000000000008683351614611fde565b61150f3373ffffffffffffffffffffffffffffffffffffffff6103c3858561271a565b61151b60218514611f24565b831561046e5761155b610b3c958435167f02000000000000000000000000000000000000000000000000000000000000008114908115610d945750611fde565b61156a60ff610d888686612145565b6124b0565b90600182811c921680156115b8575b602083101461158957565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b91607f169161157e565b8054600093926115d18261156f565b9182825260209360019160018116908160001461163957506001146115f8575b5050505050565b90939495506000929192528360002092846000945b838610611625575050505001019038808080806115f1565b80548587018301529401938590820161160d565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00168685015250505090151560051b0101915038808080806115f1565b9061169161168a92604051938480926115c2565b03836105f0565b565b907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f6020936116cf815180928187528780880191016106c0565b0116010190565b346102aa576116ec6116e736610dbe565b61077b565b60ff8154166040519161170d8361170681600185016115c2565b03846105f0565b6003600282015491015463ffffffff9061173b6040519586951515865260c0602087015260c0860190611693565b9260408501528181166060850152818160201c16608085015260401c1660a08301520390f35b346102aa5760006003193601126102aa57602073ffffffffffffffffffffffffffffffffffffffff7f9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c1993005416604051908152f35b6117bd36611439565b916117ca60418214611f24565b801561046e577fff000000000000000000000000000000000000000000000000000000000000009361150f7f04000000000000000000000000000000000000000000000000000000000000008683351614611fde565b346102aa5760206003193601126102aa57611839613254565b610b3c60043561343c565b346102aa5761185236610e1f565b9261186260218294939414611f24565b801561046e577f0200000000000000000000000000000000000000000000000000000000000000947fff000000000000000000000000000000000000000000000000000000000000006118c282358216888114908115610d945750611fde565b6118ce60218614611f24565b841561046e57610b3c966118ef91853516908114908115610d945750611fde565b6118fe60ff610d888686612145565b6125bb565b346102aa5760006003193601126102aa57611961604051611923816105cf565b600581527f352e302e300000000000000000000000000000000000000000000000000000006020820152604051918291602083526020830190611693565b0390f35b346102aa5760006003193601126102aa57602060405163ffffffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b346102aa5760006003193601126102aa5760206040517f00000000000000000000000000000000000000000000000000000000000000008152f35b346102aa5760206108276119f436610dbe565b610755565b346102aa5760206003193601126102aa576040611a17600435612616565b82519182526020820152f35b346102aa5760006003193601126102aa57602073ffffffffffffffffffffffffffffffffffffffff7f237e158222e3e6968b72b9db0d8043aacf074ad9f650f0d1606b4d82ee432c005416604051908152f35b346102aa5760206003193601126102aa57611a8f613254565b610b3c600435613530565b346102aa5760206003193601126102aa57611ab3613254565b610b3c60043561361d565b346102aa5760006003193601126102aa576020600054604051908152f35b346102aa5760206003193601126102aa57611af56102af565b611afd613254565b73ffffffffffffffffffffffffffffffffffffffff809116907f237e158222e3e6968b72b9db0d8043aacf074ad9f650f0d1606b4d82ee432c00827fffffffffffffffffffffffff00000000000000000000000000000000000000008254161790557f9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c19930054167f38d16b8cac22d99fc7c124b9cd0de2d3fa1faef420bfe791d8c362d765e22700600080a3005b346102aa5760a06003193601126102aa57611bc26102af565b7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00549067ffffffffffffffff60ff8360401c1615921680159081611da4575b6001149081611d9a575b159081611d91575b50611d6757611c869082611c6c7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a0060017fffffffffffffffffffffffffffffffffffffffffffffffff0000000000000000825416179055565b611d0b575b60843590606435906044359060243590612652565b611c8c57005b611cd87ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a007fffffffffffffffffffffffffffffffffffffffffffffff00ffffffffffffffff8154169055565b604051600181527fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d290806020810161116a565b611d627ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00680100000000000000007fffffffffffffffffffffffffffffffffffffffffffffff00ffffffffffffffff825416179055565b611c71565b60046040517ff92ee8a9000000000000000000000000000000000000000000000000000000008152fd5b90501538611c13565b303b159150611c0b565b839150611c01565b6044359063ffffffff821682036102aa57565b6064359063ffffffff821682036102aa57565b6084359063ffffffff821682036102aa57565b60a06003193601126102aa5767ffffffffffffffff6004358181116102aa57611e1290369060040161027c565b90916024359081116102aa57611e2c90369060040161027c565b919092611e37611dac565b90611e40611dbf565b92611e49611dd2565b94611e5660418314611f24565b811561046e576109d696611edd91611eb27f04000000000000000000000000000000000000000000000000000000000000007fff0000000000000000000000000000000000000000000000000000000000000087351614611fde565b611ed53373ffffffffffffffffffffffffffffffffffffffff6103c3878961271a565b6103ca6128f6565b91612c3c565b346102aa5760006003193601126102aa57602060405163ffffffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b15611f2b57565b60846040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602560248201527f4950546f6b656e5374616b696e673a20496e76616c6964207075626b6579206c60448201527f656e6774680000000000000000000000000000000000000000000000000000006064820152fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b15611fe557565b60846040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602560248201527f4950546f6b656e5374616b696e673a20496e76616c6964207075626b6579207060448201527f72656669780000000000000000000000000000000000000000000000000000006064820152fd5b1561207057565b60846040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602e60248201527f4950546f6b656e5374616b696e673a20496e76616c6964207075626b6579206460448201527f65726976656420616464726573730000000000000000000000000000000000006064820152fd5b9035907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe1813603018212156102aa570180359067ffffffffffffffff82116102aa576020019181360383136102aa57565b6020908260405193849283378101600481520301902090565b6020908260405193849283378101600781520301902090565b6020919283604051948593843782019081520301902090565b1561219757565b60846040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602860248201527f4950546f6b656e5374616b696e673a2056616c696461746f7220646f6573206e60448201527f6f742065786973740000000000000000000000000000000000000000000000006064820152fd5b6040810161222981836120f4565b929061223760218514611f24565b831561046e5760ff610d886116919583610d837fff000000000000000000000000000000000000000000000000000000000000006122a19635167f02000000000000000000000000000000000000000000000000000000000000008114908115610d945750611fde565b6122b16103d16103ca83806120f4565b6122be6060830135612616565b50926122ca3383612e8c565b6122e26122da60208501856120f4565b9290946120f4565b939092613019565b6103d16122ff9161169196959493369161066b565b613180565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b906001820180921161234157565b612304565b9190820180921161234157565b1561235a57565b60846040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603360248201527f4950546f6b656e5374616b696e673a205769746864726177616c20616464726560448201527f7373206368616e676520636f6f6c2d646f776e000000000000000000000000006064820152fd5b9291906123f5602091604086526040860190611693565b930152565b6040810161240881836120f4565b929061241660218514611f24565b831561046e5760ff610d886116919583610d837fff000000000000000000000000000000000000000000000000000000000000006124809635167f02000000000000000000000000000000000000000000000000000000000000008114908115610d945750611fde565b61248d6060820135612616565b509161249f6103d16103ca84806120f4565b906122e26122da60208501856120f4565b61258c612570936124e961257e937f6f0ca1c9f1795cb6a6ba44d788bc09dfb45b3a223470ae03e049ee954f0829ed97956103ca6128f6565b936124f334612616565b612504600096929654871015612950565b61255c612510886127bf565b916002604051868882376020818881016004815203019020018881540190556125388361072f565b88815401905561255161254a84610709565b8688612177565b8881540190556138fb565b604051978897608089526080890190611693565b908782036020890152611693565b918583036040870152612b9d565b9060608301520390a160017f9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f0055565b6122ff90611691959493926103ca336125d536848661066b565b612e8c565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b9190820391821161234157565b7f0000000000000000000000000000000000000000000000000000000000000000801561264d578106908181039081116123415791565b6125da565b9193929061265e613ab2565b612666613ab2565b60017f9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f0055612692613ab2565b61269a613ab2565b6126a2613ab2565b73ffffffffffffffffffffffffffffffffffffffff8316156126e957611691946126da6126df926126d56126e496613388565b613530565b613294565b61343c565b61361d565b60246040517f1e4fbdf700000000000000000000000000000000000000000000000000000000815260006004820152fd5b816001116102aa5773ffffffffffffffffffffffffffffffffffffffff916127699160017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff369301910161066b565b602081519101201690565b604051906060820182811067ffffffffffffffff8211176105eb5760405260218252604082602036910137565b80511561046e5760200190565b90815181101561046e570160200190565b9060418251036128725760ff6127e081604160218601519501511660011690565b1661284c577f02000000000000000000000000000000000000000000000000000000000000005b61280f612774565b9060001a61281c826127a1565b5360005b6020811061282d57509150565b80846001921a61284561283f83612333565b856127ae565b5301612820565b7f0300000000000000000000000000000000000000000000000000000000000000612807565b60846040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602660248201527f496e76616c696420756e636f6d70726573736564207075626c6963206b65792060448201527f6c656e67746800000000000000000000000000000000000000000000000000006064820152fd5b7f9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f0060028154146129265760029055565b60046040517f3ee5aeb5000000000000000000000000000000000000000000000000000000008152fd5b1561295757565b60846040517f08c379a0000000000000000000000000000000000000000000000000000000008152602060048201526024808201527f4950546f6b656e5374616b696e673a205374616b6520616d6f756e7420746f6f60448201527f206c6f77000000000000000000000000000000000000000000000000000000006064820152fd5b91612a12918354907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff9060031b92831b921b19161790565b9055565b818110612a21575050565b60008155600101612a16565b9190601f8111612a3c57505050565b611691926000526020600020906020601f840160051c83019310612a68575b601f0160051c0190612a16565b9091508190612a5b565b919091825167ffffffffffffffff81116105eb57612a9a81612a94845461156f565b84612a2d565b602080601f8311600114612af657508190612a12939495600092612aeb575b50507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8260011b9260031b1c19161790565b015190503880612ab9565b907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0831695612b2a85600052602060002090565b926000905b888210612b8557505083600195969710612b4e575b505050811b019055565b01517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff60f88460031b161c19169055388080612b44565b80600185968294968601518155019501930190612b2f565b601f82602094937fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0938186528686013760008582860101520116010190565b96949897939060c09693612bff612c0d92612c1b9560e08c5260e08c0191612b9d565b9089820360208b0152611693565b9087820360408901526115c2565b96606086015263ffffffff928380921660808701521660a085015216910152565b947f86e28854e4d50fe7db57c8bede0c9deb5abf1e451982b19cc58742edef74459f95612e549395949294612e30612c7334612616565b9094612c80861515612950565b612c8e6103d1368b8861066b565b99612c988b61077b565b94612ca4865460ff1690565b86547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00166001178755918215612e775750612ce160018701611676565b985b612cf1600188019a8b612a72565b60028701612d008a8254612346565b90558215612e6b5750612d536003612d1e8189015463ffffffff1690565b975b0196879063ffffffff167fffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000000825416179055565b8115612e6257508454612da39060201c63ffffffff165b86547fffffffffffffffffffffffffffffffffffffffffffffffff00000000ffffffff1660209190911b67ffffffff0000000016178655565b15612e5957508254612df69060401c63ffffffff165b84547fffffffffffffffffffffffffffffffffffffffff00000000ffffffffffffffff1660409190911b6bffffffff000000000000000016178455565b612dff8961072f565b612e0a868254612346565b9055612e1e612e188a610709565b8a6107a1565b612e29868254612346565b90556138fb565b549163ffffffff93604051978897868660401c1696808760201c1696169489612bdc565b0390a1565b612df690612db9565b612da390612d6a565b6003612d539197612d20565b98612ce3565b908160209103126102aa575190565b9073ffffffffffffffffffffffffffffffffffffffff612eae612ec6936106e3565b91169060019160005201602052604060002054151590565b15612ecd57565b60846040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602960248201527f4950546f6b656e5374616b696e673a2043616c6c6572206973206e6f7420616e60448201527f206f70657261746f7200000000000000000000000000000000000000000000006064820152fd5b15612f5857565b60846040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602a60248201527f4950546f6b656e5374616b696e673a20496e73756666696369656e742073746160448201527f6b656420616d6f756e74000000000000000000000000000000000000000000006064820152fd5b96959490606094926123f594612ffd61300b9360808c5260808c0190611693565b918a830360208c0152612b9d565b918783036040890152612b9d565b929194909361303d8261303561302e87610709565b8989612177565b541015612f51565b6002604051878782376020818981016004815203019020018054908382039182116123415755600261306f8285612145565b0192835496838801809811612341577fb025fa2a574dd306182c6ac63bf7b05482b99680c1b38a42d8401a0adfd3775a97612e5495556130b86130b187610709565b8289612177565b6130c3858254612609565b90556130d86130d187610709565b8484612177565b6130e3858254612346565b905560405196879687612fdc565b60036000918281558260018201613108815461156f565b80613119575b505060028201550155565b82601f8211600114613131575050555b82388061310e565b909180825261314f601f60208420940160051c840160018501612a16565b5555613129565b949392916040926131726123f593606089526060890190611693565b918783036020890152612b9d565b90919261319a8161303561319385610709565b8787612177565b60026040518585823760208187810160048152030190200190815494818603958611612341577f0526a04a9b113a046b17e2350e42123a2515b5558b3aea91576ccdb1270c1b5995612e5493556131f08461072f565b6131fb838254612609565b905561321061320985610709565b8287612177565b61321b838254612609565b905560026132298287612145565b01541561323d575b60405194859485613156565b61324f61324a8287612145565b6130f1565b613231565b73ffffffffffffffffffffffffffffffffffffffff7f9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c1993005416330361124b57565b8015613304577f0000000000000000000000000000000000000000000000000000000000000000801561264d5781068103908111612341576001556001546040519081527ff93d77980ae5a1ddd008d6a7f02cbee5af2a4fcea850c4b55828de4f644e589f908060208101612e54565b60846040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602c60248201527f4950546f6b656e5374616b696e673a206d696e556e7374616b65416d6f756e7460448201527f2063616e6e6f74206265203000000000000000000000000000000000000000006064820152fd5b7fffffffffffffffffffffffff0000000000000000000000000000000000000000907f237e158222e3e6968b72b9db0d8043aacf074ad9f650f0d1606b4d82ee432c008281541690557f9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c19930080549073ffffffffffffffffffffffffffffffffffffffff80931680948316179055167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0600080a3565b80156134ac577f0000000000000000000000000000000000000000000000000000000000000000801561264d5781068103908111612341576002556002546040519081527ff1e15ded5b5192ec1a89a3d16f49c46c7fa6c876d1f8299cf036f5abf9924d9b908060208101612e54565b60846040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602f60248201527f4950546f6b656e5374616b696e673a206d696e526564656c6567617465416d6f60448201527f756e742063616e6e6f74206265203000000000000000000000000000000000006064820152fd5b8015613599577f0000000000000000000000000000000000000000000000000000000000000000801561264d5781068103908111612341576020817fea095c2fea861b87f0fd54d0d4453358692a527e120df22b62c71696247dfb9f92600055604051908152a1565b60846040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602a60248201527f4950546f6b656e5374616b696e673a206d696e5374616b65416d6f756e74206360448201527f616e6e6f742062652030000000000000000000000000000000000000000000006064820152fd5b8015613654576020817fbed33ba1e6aacc702f8e48397b388e43ca92a8898ed8bdb389fd8b18af95d32c92600355604051908152a1565b60846040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603e60248201527f4950546f6b656e5374616b696e673a206e65775769746864726177616c41646460448201527f726573734368616e6765496e74657276616c2063616e6e6f74206265203000006064820152fd5b805482101561046e5760005260206000200190600090565b600082815260018201602052604090205461377a57805490680100000000000000008210156105eb578261376361372e8460018096018555846136d8565b81939154907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff9060031b92831b921b19161790565b905580549260005201602052604060002055600190565b5050600090565b80549081156137c9577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff809201916137b983836136d8565b909182549160031b1b1916905555565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603160045260246000fd5b60018101918060005282602052604060002054928315156000146138c2577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff92838501908582116123415780549485019485116123415760009585836138799761386a950361387f575b505050613781565b90600052602052604060002090565b55600190565b6138a96138a3916138936138b994876136d8565b90549060031b1c928391876136d8565b906129da565b8590600052602052604060002090565b55388080613862565b50505050600090565b3d156138f6573d906138dc82610631565b916138ea60405193846105f0565b82523d6000602084013e565b606090565b600080808093335af161390c6138cb565b501561391457565b60846040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602a60248201527f4950546f6b656e5374616b696e673a204661696c656420746f20726566756e6460448201527f2072656d61696e646572000000000000000000000000000000000000000000006064820152fd5b90813b15613a6b5773ffffffffffffffffffffffffffffffffffffffff82167f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc817fffffffffffffffffffffffff00000000000000000000000000000000000000008254161790557fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b600080a2805115613a3857613a3591613b0b565b50565b505034613a4157565b60046040517fb398979f000000000000000000000000000000000000000000000000000000008152fd5b60248273ffffffffffffffffffffffffffffffffffffffff604051917f4c9c8ce3000000000000000000000000000000000000000000000000000000008352166004820152fd5b60ff7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a005460401c1615613ae157565b60046040517fd7e6bcf8000000000000000000000000000000000000000000000000000000008152fd5b6000806106bd93602081519101845af4613b236138cb565b9190613b635750805115613b3957805190602001fd5b60046040517f1425ea42000000000000000000000000000000000000000000000000000000008152fd5b81511580613bbb575b613b74575090565b60249073ffffffffffffffffffffffffffffffffffffffff604051917f9996b315000000000000000000000000000000000000000000000000000000008352166004820152fd5b50803b15613b6c56fea2646970667358221220de1ce9f057900b2bfc3f0fc2c4177c813a83b46195b7e5e476abf21a987dc08864736f6c634300081700334950546f6b656e5374616b696e673a20496e76616c69642064656661756c7420",
}

// IPTokenStakingABI is the input ABI used to generate the binding from.
// Deprecated: Use IPTokenStakingMetaData.ABI instead.
var IPTokenStakingABI = IPTokenStakingMetaData.ABI

// IPTokenStakingBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use IPTokenStakingMetaData.Bin instead.
var IPTokenStakingBin = IPTokenStakingMetaData.Bin

// DeployIPTokenStaking deploys a new Ethereum contract, binding an instance of IPTokenStaking to it.
func DeployIPTokenStaking(auth *bind.TransactOpts, backend bind.ContractBackend, stakingRounding *big.Int, defaultCommissionRate uint32, defaultMaxCommissionRate uint32, defaultMaxCommissionChangeRate uint32) (common.Address, *types.Transaction, *IPTokenStaking, error) {
	parsed, err := IPTokenStakingMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(IPTokenStakingBin), backend, stakingRounding, defaultCommissionRate, defaultMaxCommissionRate, defaultMaxCommissionChangeRate)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &IPTokenStaking{IPTokenStakingCaller: IPTokenStakingCaller{contract: contract}, IPTokenStakingTransactor: IPTokenStakingTransactor{contract: contract}, IPTokenStakingFilterer: IPTokenStakingFilterer{contract: contract}}, nil
}

// IPTokenStaking is an auto generated Go binding around an Ethereum contract.
type IPTokenStaking struct {
	IPTokenStakingCaller     // Read-only binding to the contract
	IPTokenStakingTransactor // Write-only binding to the contract
	IPTokenStakingFilterer   // Log filterer for contract events
}

// IPTokenStakingCaller is an auto generated read-only Go binding around an Ethereum contract.
type IPTokenStakingCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IPTokenStakingTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IPTokenStakingTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IPTokenStakingFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IPTokenStakingFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IPTokenStakingSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IPTokenStakingSession struct {
	Contract     *IPTokenStaking   // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IPTokenStakingCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IPTokenStakingCallerSession struct {
	Contract *IPTokenStakingCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts         // Call options to use throughout this session
}

// IPTokenStakingTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IPTokenStakingTransactorSession struct {
	Contract     *IPTokenStakingTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts         // Transaction auth options to use throughout this session
}

// IPTokenStakingRaw is an auto generated low-level Go binding around an Ethereum contract.
type IPTokenStakingRaw struct {
	Contract *IPTokenStaking // Generic contract binding to access the raw methods on
}

// IPTokenStakingCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IPTokenStakingCallerRaw struct {
	Contract *IPTokenStakingCaller // Generic read-only contract binding to access the raw methods on
}

// IPTokenStakingTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IPTokenStakingTransactorRaw struct {
	Contract *IPTokenStakingTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIPTokenStaking creates a new instance of IPTokenStaking, bound to a specific deployed contract.
func NewIPTokenStaking(address common.Address, backend bind.ContractBackend) (*IPTokenStaking, error) {
	contract, err := bindIPTokenStaking(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IPTokenStaking{IPTokenStakingCaller: IPTokenStakingCaller{contract: contract}, IPTokenStakingTransactor: IPTokenStakingTransactor{contract: contract}, IPTokenStakingFilterer: IPTokenStakingFilterer{contract: contract}}, nil
}

// NewIPTokenStakingCaller creates a new read-only instance of IPTokenStaking, bound to a specific deployed contract.
func NewIPTokenStakingCaller(address common.Address, caller bind.ContractCaller) (*IPTokenStakingCaller, error) {
	contract, err := bindIPTokenStaking(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IPTokenStakingCaller{contract: contract}, nil
}

// NewIPTokenStakingTransactor creates a new write-only instance of IPTokenStaking, bound to a specific deployed contract.
func NewIPTokenStakingTransactor(address common.Address, transactor bind.ContractTransactor) (*IPTokenStakingTransactor, error) {
	contract, err := bindIPTokenStaking(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IPTokenStakingTransactor{contract: contract}, nil
}

// NewIPTokenStakingFilterer creates a new log filterer instance of IPTokenStaking, bound to a specific deployed contract.
func NewIPTokenStakingFilterer(address common.Address, filterer bind.ContractFilterer) (*IPTokenStakingFilterer, error) {
	contract, err := bindIPTokenStaking(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IPTokenStakingFilterer{contract: contract}, nil
}

// bindIPTokenStaking binds a generic wrapper to an already deployed contract.
func bindIPTokenStaking(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := IPTokenStakingMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IPTokenStaking *IPTokenStakingRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IPTokenStaking.Contract.IPTokenStakingCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IPTokenStaking *IPTokenStakingRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IPTokenStaking.Contract.IPTokenStakingTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IPTokenStaking *IPTokenStakingRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IPTokenStaking.Contract.IPTokenStakingTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IPTokenStaking *IPTokenStakingCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IPTokenStaking.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IPTokenStaking *IPTokenStakingTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IPTokenStaking.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IPTokenStaking *IPTokenStakingTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IPTokenStaking.Contract.contract.Transact(opts, method, params...)
}

// DEFAULTCOMMISSIONRATE is a free data retrieval call binding the contract method 0xb8db983e.
//
// Solidity: function DEFAULT_COMMISSION_RATE() view returns(uint32)
func (_IPTokenStaking *IPTokenStakingCaller) DEFAULTCOMMISSIONRATE(opts *bind.CallOpts) (uint32, error) {
	var out []interface{}
	err := _IPTokenStaking.contract.Call(opts, &out, "DEFAULT_COMMISSION_RATE")

	if err != nil {
		return *new(uint32), err
	}

	out0 := *abi.ConvertType(out[0], new(uint32)).(*uint32)

	return out0, err

}

// DEFAULTCOMMISSIONRATE is a free data retrieval call binding the contract method 0xb8db983e.
//
// Solidity: function DEFAULT_COMMISSION_RATE() view returns(uint32)
func (_IPTokenStaking *IPTokenStakingSession) DEFAULTCOMMISSIONRATE() (uint32, error) {
	return _IPTokenStaking.Contract.DEFAULTCOMMISSIONRATE(&_IPTokenStaking.CallOpts)
}

// DEFAULTCOMMISSIONRATE is a free data retrieval call binding the contract method 0xb8db983e.
//
// Solidity: function DEFAULT_COMMISSION_RATE() view returns(uint32)
func (_IPTokenStaking *IPTokenStakingCallerSession) DEFAULTCOMMISSIONRATE() (uint32, error) {
	return _IPTokenStaking.Contract.DEFAULTCOMMISSIONRATE(&_IPTokenStaking.CallOpts)
}

// DEFAULTMAXCOMMISSIONCHANGERATE is a free data retrieval call binding the contract method 0xfc56c2a2.
//
// Solidity: function DEFAULT_MAX_COMMISSION_CHANGE_RATE() view returns(uint32)
func (_IPTokenStaking *IPTokenStakingCaller) DEFAULTMAXCOMMISSIONCHANGERATE(opts *bind.CallOpts) (uint32, error) {
	var out []interface{}
	err := _IPTokenStaking.contract.Call(opts, &out, "DEFAULT_MAX_COMMISSION_CHANGE_RATE")

	if err != nil {
		return *new(uint32), err
	}

	out0 := *abi.ConvertType(out[0], new(uint32)).(*uint32)

	return out0, err

}

// DEFAULTMAXCOMMISSIONCHANGERATE is a free data retrieval call binding the contract method 0xfc56c2a2.
//
// Solidity: function DEFAULT_MAX_COMMISSION_CHANGE_RATE() view returns(uint32)
func (_IPTokenStaking *IPTokenStakingSession) DEFAULTMAXCOMMISSIONCHANGERATE() (uint32, error) {
	return _IPTokenStaking.Contract.DEFAULTMAXCOMMISSIONCHANGERATE(&_IPTokenStaking.CallOpts)
}

// DEFAULTMAXCOMMISSIONCHANGERATE is a free data retrieval call binding the contract method 0xfc56c2a2.
//
// Solidity: function DEFAULT_MAX_COMMISSION_CHANGE_RATE() view returns(uint32)
func (_IPTokenStaking *IPTokenStakingCallerSession) DEFAULTMAXCOMMISSIONCHANGERATE() (uint32, error) {
	return _IPTokenStaking.Contract.DEFAULTMAXCOMMISSIONCHANGERATE(&_IPTokenStaking.CallOpts)
}

// DEFAULTMAXCOMMISSIONRATE is a free data retrieval call binding the contract method 0x2ebc6034.
//
// Solidity: function DEFAULT_MAX_COMMISSION_RATE() view returns(uint32)
func (_IPTokenStaking *IPTokenStakingCaller) DEFAULTMAXCOMMISSIONRATE(opts *bind.CallOpts) (uint32, error) {
	var out []interface{}
	err := _IPTokenStaking.contract.Call(opts, &out, "DEFAULT_MAX_COMMISSION_RATE")

	if err != nil {
		return *new(uint32), err
	}

	out0 := *abi.ConvertType(out[0], new(uint32)).(*uint32)

	return out0, err

}

// DEFAULTMAXCOMMISSIONRATE is a free data retrieval call binding the contract method 0x2ebc6034.
//
// Solidity: function DEFAULT_MAX_COMMISSION_RATE() view returns(uint32)
func (_IPTokenStaking *IPTokenStakingSession) DEFAULTMAXCOMMISSIONRATE() (uint32, error) {
	return _IPTokenStaking.Contract.DEFAULTMAXCOMMISSIONRATE(&_IPTokenStaking.CallOpts)
}

// DEFAULTMAXCOMMISSIONRATE is a free data retrieval call binding the contract method 0x2ebc6034.
//
// Solidity: function DEFAULT_MAX_COMMISSION_RATE() view returns(uint32)
func (_IPTokenStaking *IPTokenStakingCallerSession) DEFAULTMAXCOMMISSIONRATE() (uint32, error) {
	return _IPTokenStaking.Contract.DEFAULTMAXCOMMISSIONRATE(&_IPTokenStaking.CallOpts)
}

// STAKEROUNDING is a free data retrieval call binding the contract method 0xbda16b15.
//
// Solidity: function STAKE_ROUNDING() view returns(uint256)
func (_IPTokenStaking *IPTokenStakingCaller) STAKEROUNDING(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _IPTokenStaking.contract.Call(opts, &out, "STAKE_ROUNDING")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// STAKEROUNDING is a free data retrieval call binding the contract method 0xbda16b15.
//
// Solidity: function STAKE_ROUNDING() view returns(uint256)
func (_IPTokenStaking *IPTokenStakingSession) STAKEROUNDING() (*big.Int, error) {
	return _IPTokenStaking.Contract.STAKEROUNDING(&_IPTokenStaking.CallOpts)
}

// STAKEROUNDING is a free data retrieval call binding the contract method 0xbda16b15.
//
// Solidity: function STAKE_ROUNDING() view returns(uint256)
func (_IPTokenStaking *IPTokenStakingCallerSession) STAKEROUNDING() (*big.Int, error) {
	return _IPTokenStaking.Contract.STAKEROUNDING(&_IPTokenStaking.CallOpts)
}

// UPGRADEINTERFACEVERSION is a free data retrieval call binding the contract method 0xad3cb1cc.
//
// Solidity: function UPGRADE_INTERFACE_VERSION() view returns(string)
func (_IPTokenStaking *IPTokenStakingCaller) UPGRADEINTERFACEVERSION(opts *bind.CallOpts) (string, error) {
	var out []interface{}
	err := _IPTokenStaking.contract.Call(opts, &out, "UPGRADE_INTERFACE_VERSION")

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// UPGRADEINTERFACEVERSION is a free data retrieval call binding the contract method 0xad3cb1cc.
//
// Solidity: function UPGRADE_INTERFACE_VERSION() view returns(string)
func (_IPTokenStaking *IPTokenStakingSession) UPGRADEINTERFACEVERSION() (string, error) {
	return _IPTokenStaking.Contract.UPGRADEINTERFACEVERSION(&_IPTokenStaking.CallOpts)
}

// UPGRADEINTERFACEVERSION is a free data retrieval call binding the contract method 0xad3cb1cc.
//
// Solidity: function UPGRADE_INTERFACE_VERSION() view returns(string)
func (_IPTokenStaking *IPTokenStakingCallerSession) UPGRADEINTERFACEVERSION() (string, error) {
	return _IPTokenStaking.Contract.UPGRADEINTERFACEVERSION(&_IPTokenStaking.CallOpts)
}

// DelegatorTotalStakes is a free data retrieval call binding the contract method 0x57067503.
//
// Solidity: function delegatorTotalStakes(bytes delegatorCmpPubkey) view returns(uint256 stakedAmount)
func (_IPTokenStaking *IPTokenStakingCaller) DelegatorTotalStakes(opts *bind.CallOpts, delegatorCmpPubkey []byte) (*big.Int, error) {
	var out []interface{}
	err := _IPTokenStaking.contract.Call(opts, &out, "delegatorTotalStakes", delegatorCmpPubkey)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// DelegatorTotalStakes is a free data retrieval call binding the contract method 0x57067503.
//
// Solidity: function delegatorTotalStakes(bytes delegatorCmpPubkey) view returns(uint256 stakedAmount)
func (_IPTokenStaking *IPTokenStakingSession) DelegatorTotalStakes(delegatorCmpPubkey []byte) (*big.Int, error) {
	return _IPTokenStaking.Contract.DelegatorTotalStakes(&_IPTokenStaking.CallOpts, delegatorCmpPubkey)
}

// DelegatorTotalStakes is a free data retrieval call binding the contract method 0x57067503.
//
// Solidity: function delegatorTotalStakes(bytes delegatorCmpPubkey) view returns(uint256 stakedAmount)
func (_IPTokenStaking *IPTokenStakingCallerSession) DelegatorTotalStakes(delegatorCmpPubkey []byte) (*big.Int, error) {
	return _IPTokenStaking.Contract.DelegatorTotalStakes(&_IPTokenStaking.CallOpts, delegatorCmpPubkey)
}

// DelegatorValidatorStakes is a free data retrieval call binding the contract method 0x2d1e973e.
//
// Solidity: function delegatorValidatorStakes(bytes delegatorCmpPubkey, bytes validatorCmpPubkey) view returns(uint256 stakedAmount)
func (_IPTokenStaking *IPTokenStakingCaller) DelegatorValidatorStakes(opts *bind.CallOpts, delegatorCmpPubkey []byte, validatorCmpPubkey []byte) (*big.Int, error) {
	var out []interface{}
	err := _IPTokenStaking.contract.Call(opts, &out, "delegatorValidatorStakes", delegatorCmpPubkey, validatorCmpPubkey)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// DelegatorValidatorStakes is a free data retrieval call binding the contract method 0x2d1e973e.
//
// Solidity: function delegatorValidatorStakes(bytes delegatorCmpPubkey, bytes validatorCmpPubkey) view returns(uint256 stakedAmount)
func (_IPTokenStaking *IPTokenStakingSession) DelegatorValidatorStakes(delegatorCmpPubkey []byte, validatorCmpPubkey []byte) (*big.Int, error) {
	return _IPTokenStaking.Contract.DelegatorValidatorStakes(&_IPTokenStaking.CallOpts, delegatorCmpPubkey, validatorCmpPubkey)
}

// DelegatorValidatorStakes is a free data retrieval call binding the contract method 0x2d1e973e.
//
// Solidity: function delegatorValidatorStakes(bytes delegatorCmpPubkey, bytes validatorCmpPubkey) view returns(uint256 stakedAmount)
func (_IPTokenStaking *IPTokenStakingCallerSession) DelegatorValidatorStakes(delegatorCmpPubkey []byte, validatorCmpPubkey []byte) (*big.Int, error) {
	return _IPTokenStaking.Contract.DelegatorValidatorStakes(&_IPTokenStaking.CallOpts, delegatorCmpPubkey, validatorCmpPubkey)
}

// GetOperators is a free data retrieval call binding the contract method 0x83dffd6f.
//
// Solidity: function getOperators(bytes pubkey) view returns(address[])
func (_IPTokenStaking *IPTokenStakingCaller) GetOperators(opts *bind.CallOpts, pubkey []byte) ([]common.Address, error) {
	var out []interface{}
	err := _IPTokenStaking.contract.Call(opts, &out, "getOperators", pubkey)

	if err != nil {
		return *new([]common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new([]common.Address)).(*[]common.Address)

	return out0, err

}

// GetOperators is a free data retrieval call binding the contract method 0x83dffd6f.
//
// Solidity: function getOperators(bytes pubkey) view returns(address[])
func (_IPTokenStaking *IPTokenStakingSession) GetOperators(pubkey []byte) ([]common.Address, error) {
	return _IPTokenStaking.Contract.GetOperators(&_IPTokenStaking.CallOpts, pubkey)
}

// GetOperators is a free data retrieval call binding the contract method 0x83dffd6f.
//
// Solidity: function getOperators(bytes pubkey) view returns(address[])
func (_IPTokenStaking *IPTokenStakingCallerSession) GetOperators(pubkey []byte) ([]common.Address, error) {
	return _IPTokenStaking.Contract.GetOperators(&_IPTokenStaking.CallOpts, pubkey)
}

// MinRedelegateAmount is a free data retrieval call binding the contract method 0x5a69825d.
//
// Solidity: function minRedelegateAmount() view returns(uint256)
func (_IPTokenStaking *IPTokenStakingCaller) MinRedelegateAmount(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _IPTokenStaking.contract.Call(opts, &out, "minRedelegateAmount")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// MinRedelegateAmount is a free data retrieval call binding the contract method 0x5a69825d.
//
// Solidity: function minRedelegateAmount() view returns(uint256)
func (_IPTokenStaking *IPTokenStakingSession) MinRedelegateAmount() (*big.Int, error) {
	return _IPTokenStaking.Contract.MinRedelegateAmount(&_IPTokenStaking.CallOpts)
}

// MinRedelegateAmount is a free data retrieval call binding the contract method 0x5a69825d.
//
// Solidity: function minRedelegateAmount() view returns(uint256)
func (_IPTokenStaking *IPTokenStakingCallerSession) MinRedelegateAmount() (*big.Int, error) {
	return _IPTokenStaking.Contract.MinRedelegateAmount(&_IPTokenStaking.CallOpts)
}

// MinStakeAmount is a free data retrieval call binding the contract method 0xf1887684.
//
// Solidity: function minStakeAmount() view returns(uint256)
func (_IPTokenStaking *IPTokenStakingCaller) MinStakeAmount(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _IPTokenStaking.contract.Call(opts, &out, "minStakeAmount")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// MinStakeAmount is a free data retrieval call binding the contract method 0xf1887684.
//
// Solidity: function minStakeAmount() view returns(uint256)
func (_IPTokenStaking *IPTokenStakingSession) MinStakeAmount() (*big.Int, error) {
	return _IPTokenStaking.Contract.MinStakeAmount(&_IPTokenStaking.CallOpts)
}

// MinStakeAmount is a free data retrieval call binding the contract method 0xf1887684.
//
// Solidity: function minStakeAmount() view returns(uint256)
func (_IPTokenStaking *IPTokenStakingCallerSession) MinStakeAmount() (*big.Int, error) {
	return _IPTokenStaking.Contract.MinStakeAmount(&_IPTokenStaking.CallOpts)
}

// MinUnstakeAmount is a free data retrieval call binding the contract method 0x39ec4df9.
//
// Solidity: function minUnstakeAmount() view returns(uint256)
func (_IPTokenStaking *IPTokenStakingCaller) MinUnstakeAmount(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _IPTokenStaking.contract.Call(opts, &out, "minUnstakeAmount")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// MinUnstakeAmount is a free data retrieval call binding the contract method 0x39ec4df9.
//
// Solidity: function minUnstakeAmount() view returns(uint256)
func (_IPTokenStaking *IPTokenStakingSession) MinUnstakeAmount() (*big.Int, error) {
	return _IPTokenStaking.Contract.MinUnstakeAmount(&_IPTokenStaking.CallOpts)
}

// MinUnstakeAmount is a free data retrieval call binding the contract method 0x39ec4df9.
//
// Solidity: function minUnstakeAmount() view returns(uint256)
func (_IPTokenStaking *IPTokenStakingCallerSession) MinUnstakeAmount() (*big.Int, error) {
	return _IPTokenStaking.Contract.MinUnstakeAmount(&_IPTokenStaking.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_IPTokenStaking *IPTokenStakingCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _IPTokenStaking.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_IPTokenStaking *IPTokenStakingSession) Owner() (common.Address, error) {
	return _IPTokenStaking.Contract.Owner(&_IPTokenStaking.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_IPTokenStaking *IPTokenStakingCallerSession) Owner() (common.Address, error) {
	return _IPTokenStaking.Contract.Owner(&_IPTokenStaking.CallOpts)
}

// PendingOwner is a free data retrieval call binding the contract method 0xe30c3978.
//
// Solidity: function pendingOwner() view returns(address)
func (_IPTokenStaking *IPTokenStakingCaller) PendingOwner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _IPTokenStaking.contract.Call(opts, &out, "pendingOwner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// PendingOwner is a free data retrieval call binding the contract method 0xe30c3978.
//
// Solidity: function pendingOwner() view returns(address)
func (_IPTokenStaking *IPTokenStakingSession) PendingOwner() (common.Address, error) {
	return _IPTokenStaking.Contract.PendingOwner(&_IPTokenStaking.CallOpts)
}

// PendingOwner is a free data retrieval call binding the contract method 0xe30c3978.
//
// Solidity: function pendingOwner() view returns(address)
func (_IPTokenStaking *IPTokenStakingCallerSession) PendingOwner() (common.Address, error) {
	return _IPTokenStaking.Contract.PendingOwner(&_IPTokenStaking.CallOpts)
}

// ProxiableUUID is a free data retrieval call binding the contract method 0x52d1902d.
//
// Solidity: function proxiableUUID() view returns(bytes32)
func (_IPTokenStaking *IPTokenStakingCaller) ProxiableUUID(opts *bind.CallOpts) ([32]byte, error) {
	var out []interface{}
	err := _IPTokenStaking.contract.Call(opts, &out, "proxiableUUID")

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// ProxiableUUID is a free data retrieval call binding the contract method 0x52d1902d.
//
// Solidity: function proxiableUUID() view returns(bytes32)
func (_IPTokenStaking *IPTokenStakingSession) ProxiableUUID() ([32]byte, error) {
	return _IPTokenStaking.Contract.ProxiableUUID(&_IPTokenStaking.CallOpts)
}

// ProxiableUUID is a free data retrieval call binding the contract method 0x52d1902d.
//
// Solidity: function proxiableUUID() view returns(bytes32)
func (_IPTokenStaking *IPTokenStakingCallerSession) ProxiableUUID() ([32]byte, error) {
	return _IPTokenStaking.Contract.ProxiableUUID(&_IPTokenStaking.CallOpts)
}

// RoundedStakeAmount is a free data retrieval call binding the contract method 0xd2e1f5b8.
//
// Solidity: function roundedStakeAmount(uint256 rawAmount) view returns(uint256 amount, uint256 remainder)
func (_IPTokenStaking *IPTokenStakingCaller) RoundedStakeAmount(opts *bind.CallOpts, rawAmount *big.Int) (struct {
	Amount    *big.Int
	Remainder *big.Int
}, error) {
	var out []interface{}
	err := _IPTokenStaking.contract.Call(opts, &out, "roundedStakeAmount", rawAmount)

	outstruct := new(struct {
		Amount    *big.Int
		Remainder *big.Int
	})
	if err != nil {
		return *outstruct, err
	}

	outstruct.Amount = *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)
	outstruct.Remainder = *abi.ConvertType(out[1], new(*big.Int)).(**big.Int)

	return *outstruct, err

}

// RoundedStakeAmount is a free data retrieval call binding the contract method 0xd2e1f5b8.
//
// Solidity: function roundedStakeAmount(uint256 rawAmount) view returns(uint256 amount, uint256 remainder)
func (_IPTokenStaking *IPTokenStakingSession) RoundedStakeAmount(rawAmount *big.Int) (struct {
	Amount    *big.Int
	Remainder *big.Int
}, error) {
	return _IPTokenStaking.Contract.RoundedStakeAmount(&_IPTokenStaking.CallOpts, rawAmount)
}

// RoundedStakeAmount is a free data retrieval call binding the contract method 0xd2e1f5b8.
//
// Solidity: function roundedStakeAmount(uint256 rawAmount) view returns(uint256 amount, uint256 remainder)
func (_IPTokenStaking *IPTokenStakingCallerSession) RoundedStakeAmount(rawAmount *big.Int) (struct {
	Amount    *big.Int
	Remainder *big.Int
}, error) {
	return _IPTokenStaking.Contract.RoundedStakeAmount(&_IPTokenStaking.CallOpts, rawAmount)
}

// ValidatorMetadata is a free data retrieval call binding the contract method 0x8d3e1e41.
//
// Solidity: function validatorMetadata(bytes validatorCmpPubkey) view returns(bool exists, string moniker, uint256 totalStake, uint32 commissionRate, uint32 maxCommissionRate, uint32 maxCommissionChangeRate)
func (_IPTokenStaking *IPTokenStakingCaller) ValidatorMetadata(opts *bind.CallOpts, validatorCmpPubkey []byte) (struct {
	Exists                  bool
	Moniker                 string
	TotalStake              *big.Int
	CommissionRate          uint32
	MaxCommissionRate       uint32
	MaxCommissionChangeRate uint32
}, error) {
	var out []interface{}
	err := _IPTokenStaking.contract.Call(opts, &out, "validatorMetadata", validatorCmpPubkey)

	outstruct := new(struct {
		Exists                  bool
		Moniker                 string
		TotalStake              *big.Int
		CommissionRate          uint32
		MaxCommissionRate       uint32
		MaxCommissionChangeRate uint32
	})
	if err != nil {
		return *outstruct, err
	}

	outstruct.Exists = *abi.ConvertType(out[0], new(bool)).(*bool)
	outstruct.Moniker = *abi.ConvertType(out[1], new(string)).(*string)
	outstruct.TotalStake = *abi.ConvertType(out[2], new(*big.Int)).(**big.Int)
	outstruct.CommissionRate = *abi.ConvertType(out[3], new(uint32)).(*uint32)
	outstruct.MaxCommissionRate = *abi.ConvertType(out[4], new(uint32)).(*uint32)
	outstruct.MaxCommissionChangeRate = *abi.ConvertType(out[5], new(uint32)).(*uint32)

	return *outstruct, err

}

// ValidatorMetadata is a free data retrieval call binding the contract method 0x8d3e1e41.
//
// Solidity: function validatorMetadata(bytes validatorCmpPubkey) view returns(bool exists, string moniker, uint256 totalStake, uint32 commissionRate, uint32 maxCommissionRate, uint32 maxCommissionChangeRate)
func (_IPTokenStaking *IPTokenStakingSession) ValidatorMetadata(validatorCmpPubkey []byte) (struct {
	Exists                  bool
	Moniker                 string
	TotalStake              *big.Int
	CommissionRate          uint32
	MaxCommissionRate       uint32
	MaxCommissionChangeRate uint32
}, error) {
	return _IPTokenStaking.Contract.ValidatorMetadata(&_IPTokenStaking.CallOpts, validatorCmpPubkey)
}

// ValidatorMetadata is a free data retrieval call binding the contract method 0x8d3e1e41.
//
// Solidity: function validatorMetadata(bytes validatorCmpPubkey) view returns(bool exists, string moniker, uint256 totalStake, uint32 commissionRate, uint32 maxCommissionRate, uint32 maxCommissionChangeRate)
func (_IPTokenStaking *IPTokenStakingCallerSession) ValidatorMetadata(validatorCmpPubkey []byte) (struct {
	Exists                  bool
	Moniker                 string
	TotalStake              *big.Int
	CommissionRate          uint32
	MaxCommissionRate       uint32
	MaxCommissionChangeRate uint32
}, error) {
	return _IPTokenStaking.Contract.ValidatorMetadata(&_IPTokenStaking.CallOpts, validatorCmpPubkey)
}

// WithdrawalAddressChange is a free data retrieval call binding the contract method 0xc24ae586.
//
// Solidity: function withdrawalAddressChange(bytes delegatorCmpPubkey) view returns(uint256 lastChange)
func (_IPTokenStaking *IPTokenStakingCaller) WithdrawalAddressChange(opts *bind.CallOpts, delegatorCmpPubkey []byte) (*big.Int, error) {
	var out []interface{}
	err := _IPTokenStaking.contract.Call(opts, &out, "withdrawalAddressChange", delegatorCmpPubkey)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// WithdrawalAddressChange is a free data retrieval call binding the contract method 0xc24ae586.
//
// Solidity: function withdrawalAddressChange(bytes delegatorCmpPubkey) view returns(uint256 lastChange)
func (_IPTokenStaking *IPTokenStakingSession) WithdrawalAddressChange(delegatorCmpPubkey []byte) (*big.Int, error) {
	return _IPTokenStaking.Contract.WithdrawalAddressChange(&_IPTokenStaking.CallOpts, delegatorCmpPubkey)
}

// WithdrawalAddressChange is a free data retrieval call binding the contract method 0xc24ae586.
//
// Solidity: function withdrawalAddressChange(bytes delegatorCmpPubkey) view returns(uint256 lastChange)
func (_IPTokenStaking *IPTokenStakingCallerSession) WithdrawalAddressChange(delegatorCmpPubkey []byte) (*big.Int, error) {
	return _IPTokenStaking.Contract.WithdrawalAddressChange(&_IPTokenStaking.CallOpts, delegatorCmpPubkey)
}

// WithdrawalAddressChangeInterval is a free data retrieval call binding the contract method 0x060ceab0.
//
// Solidity: function withdrawalAddressChangeInterval() view returns(uint256)
func (_IPTokenStaking *IPTokenStakingCaller) WithdrawalAddressChangeInterval(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _IPTokenStaking.contract.Call(opts, &out, "withdrawalAddressChangeInterval")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// WithdrawalAddressChangeInterval is a free data retrieval call binding the contract method 0x060ceab0.
//
// Solidity: function withdrawalAddressChangeInterval() view returns(uint256)
func (_IPTokenStaking *IPTokenStakingSession) WithdrawalAddressChangeInterval() (*big.Int, error) {
	return _IPTokenStaking.Contract.WithdrawalAddressChangeInterval(&_IPTokenStaking.CallOpts)
}

// WithdrawalAddressChangeInterval is a free data retrieval call binding the contract method 0x060ceab0.
//
// Solidity: function withdrawalAddressChangeInterval() view returns(uint256)
func (_IPTokenStaking *IPTokenStakingCallerSession) WithdrawalAddressChangeInterval() (*big.Int, error) {
	return _IPTokenStaking.Contract.WithdrawalAddressChangeInterval(&_IPTokenStaking.CallOpts)
}

// AcceptOwnership is a paid mutator transaction binding the contract method 0x79ba5097.
//
// Solidity: function acceptOwnership() returns()
func (_IPTokenStaking *IPTokenStakingTransactor) AcceptOwnership(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IPTokenStaking.contract.Transact(opts, "acceptOwnership")
}

// AcceptOwnership is a paid mutator transaction binding the contract method 0x79ba5097.
//
// Solidity: function acceptOwnership() returns()
func (_IPTokenStaking *IPTokenStakingSession) AcceptOwnership() (*types.Transaction, error) {
	return _IPTokenStaking.Contract.AcceptOwnership(&_IPTokenStaking.TransactOpts)
}

// AcceptOwnership is a paid mutator transaction binding the contract method 0x79ba5097.
//
// Solidity: function acceptOwnership() returns()
func (_IPTokenStaking *IPTokenStakingTransactorSession) AcceptOwnership() (*types.Transaction, error) {
	return _IPTokenStaking.Contract.AcceptOwnership(&_IPTokenStaking.TransactOpts)
}

// AddOperator is a paid mutator transaction binding the contract method 0x057b9296.
//
// Solidity: function addOperator(bytes uncmpPubkey, address operator) returns()
func (_IPTokenStaking *IPTokenStakingTransactor) AddOperator(opts *bind.TransactOpts, uncmpPubkey []byte, operator common.Address) (*types.Transaction, error) {
	return _IPTokenStaking.contract.Transact(opts, "addOperator", uncmpPubkey, operator)
}

// AddOperator is a paid mutator transaction binding the contract method 0x057b9296.
//
// Solidity: function addOperator(bytes uncmpPubkey, address operator) returns()
func (_IPTokenStaking *IPTokenStakingSession) AddOperator(uncmpPubkey []byte, operator common.Address) (*types.Transaction, error) {
	return _IPTokenStaking.Contract.AddOperator(&_IPTokenStaking.TransactOpts, uncmpPubkey, operator)
}

// AddOperator is a paid mutator transaction binding the contract method 0x057b9296.
//
// Solidity: function addOperator(bytes uncmpPubkey, address operator) returns()
func (_IPTokenStaking *IPTokenStakingTransactorSession) AddOperator(uncmpPubkey []byte, operator common.Address) (*types.Transaction, error) {
	return _IPTokenStaking.Contract.AddOperator(&_IPTokenStaking.TransactOpts, uncmpPubkey, operator)
}

// CreateValidator is a paid mutator transaction binding the contract method 0xfc2e5932.
//
// Solidity: function createValidator(bytes validatorUncmpPubkey, string moniker, uint32 commissionRate, uint32 maxCommissionRate, uint32 maxCommissionChangeRate) payable returns()
func (_IPTokenStaking *IPTokenStakingTransactor) CreateValidator(opts *bind.TransactOpts, validatorUncmpPubkey []byte, moniker string, commissionRate uint32, maxCommissionRate uint32, maxCommissionChangeRate uint32) (*types.Transaction, error) {
	return _IPTokenStaking.contract.Transact(opts, "createValidator", validatorUncmpPubkey, moniker, commissionRate, maxCommissionRate, maxCommissionChangeRate)
}

// CreateValidator is a paid mutator transaction binding the contract method 0xfc2e5932.
//
// Solidity: function createValidator(bytes validatorUncmpPubkey, string moniker, uint32 commissionRate, uint32 maxCommissionRate, uint32 maxCommissionChangeRate) payable returns()
func (_IPTokenStaking *IPTokenStakingSession) CreateValidator(validatorUncmpPubkey []byte, moniker string, commissionRate uint32, maxCommissionRate uint32, maxCommissionChangeRate uint32) (*types.Transaction, error) {
	return _IPTokenStaking.Contract.CreateValidator(&_IPTokenStaking.TransactOpts, validatorUncmpPubkey, moniker, commissionRate, maxCommissionRate, maxCommissionChangeRate)
}

// CreateValidator is a paid mutator transaction binding the contract method 0xfc2e5932.
//
// Solidity: function createValidator(bytes validatorUncmpPubkey, string moniker, uint32 commissionRate, uint32 maxCommissionRate, uint32 maxCommissionChangeRate) payable returns()
func (_IPTokenStaking *IPTokenStakingTransactorSession) CreateValidator(validatorUncmpPubkey []byte, moniker string, commissionRate uint32, maxCommissionRate uint32, maxCommissionChangeRate uint32) (*types.Transaction, error) {
	return _IPTokenStaking.Contract.CreateValidator(&_IPTokenStaking.TransactOpts, validatorUncmpPubkey, moniker, commissionRate, maxCommissionRate, maxCommissionChangeRate)
}

// CreateValidatorOnBehalf is a paid mutator transaction binding the contract method 0x48903e38.
//
// Solidity: function createValidatorOnBehalf(bytes validatorUncmpPubkey) payable returns()
func (_IPTokenStaking *IPTokenStakingTransactor) CreateValidatorOnBehalf(opts *bind.TransactOpts, validatorUncmpPubkey []byte) (*types.Transaction, error) {
	return _IPTokenStaking.contract.Transact(opts, "createValidatorOnBehalf", validatorUncmpPubkey)
}

// CreateValidatorOnBehalf is a paid mutator transaction binding the contract method 0x48903e38.
//
// Solidity: function createValidatorOnBehalf(bytes validatorUncmpPubkey) payable returns()
func (_IPTokenStaking *IPTokenStakingSession) CreateValidatorOnBehalf(validatorUncmpPubkey []byte) (*types.Transaction, error) {
	return _IPTokenStaking.Contract.CreateValidatorOnBehalf(&_IPTokenStaking.TransactOpts, validatorUncmpPubkey)
}

// CreateValidatorOnBehalf is a paid mutator transaction binding the contract method 0x48903e38.
//
// Solidity: function createValidatorOnBehalf(bytes validatorUncmpPubkey) payable returns()
func (_IPTokenStaking *IPTokenStakingTransactorSession) CreateValidatorOnBehalf(validatorUncmpPubkey []byte) (*types.Transaction, error) {
	return _IPTokenStaking.Contract.CreateValidatorOnBehalf(&_IPTokenStaking.TransactOpts, validatorUncmpPubkey)
}

// Initialize is a paid mutator transaction binding the contract method 0xf92ad219.
//
// Solidity: function initialize(address accessManager, uint256 _minStakeAmount, uint256 _minUnstakeAmount, uint256 _minRedelegateAmount, uint256 _withdrawalAddressChangeInterval) returns()
func (_IPTokenStaking *IPTokenStakingTransactor) Initialize(opts *bind.TransactOpts, accessManager common.Address, _minStakeAmount *big.Int, _minUnstakeAmount *big.Int, _minRedelegateAmount *big.Int, _withdrawalAddressChangeInterval *big.Int) (*types.Transaction, error) {
	return _IPTokenStaking.contract.Transact(opts, "initialize", accessManager, _minStakeAmount, _minUnstakeAmount, _minRedelegateAmount, _withdrawalAddressChangeInterval)
}

// Initialize is a paid mutator transaction binding the contract method 0xf92ad219.
//
// Solidity: function initialize(address accessManager, uint256 _minStakeAmount, uint256 _minUnstakeAmount, uint256 _minRedelegateAmount, uint256 _withdrawalAddressChangeInterval) returns()
func (_IPTokenStaking *IPTokenStakingSession) Initialize(accessManager common.Address, _minStakeAmount *big.Int, _minUnstakeAmount *big.Int, _minRedelegateAmount *big.Int, _withdrawalAddressChangeInterval *big.Int) (*types.Transaction, error) {
	return _IPTokenStaking.Contract.Initialize(&_IPTokenStaking.TransactOpts, accessManager, _minStakeAmount, _minUnstakeAmount, _minRedelegateAmount, _withdrawalAddressChangeInterval)
}

// Initialize is a paid mutator transaction binding the contract method 0xf92ad219.
//
// Solidity: function initialize(address accessManager, uint256 _minStakeAmount, uint256 _minUnstakeAmount, uint256 _minRedelegateAmount, uint256 _withdrawalAddressChangeInterval) returns()
func (_IPTokenStaking *IPTokenStakingTransactorSession) Initialize(accessManager common.Address, _minStakeAmount *big.Int, _minUnstakeAmount *big.Int, _minRedelegateAmount *big.Int, _withdrawalAddressChangeInterval *big.Int) (*types.Transaction, error) {
	return _IPTokenStaking.Contract.Initialize(&_IPTokenStaking.TransactOpts, accessManager, _minStakeAmount, _minUnstakeAmount, _minRedelegateAmount, _withdrawalAddressChangeInterval)
}

// Redelegate is a paid mutator transaction binding the contract method 0x7b6e842c.
//
// Solidity: function redelegate((bytes,bytes,bytes,uint256) p) returns()
func (_IPTokenStaking *IPTokenStakingTransactor) Redelegate(opts *bind.TransactOpts, p IIPTokenStakingRedelegateParams) (*types.Transaction, error) {
	return _IPTokenStaking.contract.Transact(opts, "redelegate", p)
}

// Redelegate is a paid mutator transaction binding the contract method 0x7b6e842c.
//
// Solidity: function redelegate((bytes,bytes,bytes,uint256) p) returns()
func (_IPTokenStaking *IPTokenStakingSession) Redelegate(p IIPTokenStakingRedelegateParams) (*types.Transaction, error) {
	return _IPTokenStaking.Contract.Redelegate(&_IPTokenStaking.TransactOpts, p)
}

// Redelegate is a paid mutator transaction binding the contract method 0x7b6e842c.
//
// Solidity: function redelegate((bytes,bytes,bytes,uint256) p) returns()
func (_IPTokenStaking *IPTokenStakingTransactorSession) Redelegate(p IIPTokenStakingRedelegateParams) (*types.Transaction, error) {
	return _IPTokenStaking.Contract.Redelegate(&_IPTokenStaking.TransactOpts, p)
}

// RedelegateOnBehalf is a paid mutator transaction binding the contract method 0x53972c2a.
//
// Solidity: function redelegateOnBehalf((bytes,bytes,bytes,uint256) p) returns()
func (_IPTokenStaking *IPTokenStakingTransactor) RedelegateOnBehalf(opts *bind.TransactOpts, p IIPTokenStakingRedelegateParams) (*types.Transaction, error) {
	return _IPTokenStaking.contract.Transact(opts, "redelegateOnBehalf", p)
}

// RedelegateOnBehalf is a paid mutator transaction binding the contract method 0x53972c2a.
//
// Solidity: function redelegateOnBehalf((bytes,bytes,bytes,uint256) p) returns()
func (_IPTokenStaking *IPTokenStakingSession) RedelegateOnBehalf(p IIPTokenStakingRedelegateParams) (*types.Transaction, error) {
	return _IPTokenStaking.Contract.RedelegateOnBehalf(&_IPTokenStaking.TransactOpts, p)
}

// RedelegateOnBehalf is a paid mutator transaction binding the contract method 0x53972c2a.
//
// Solidity: function redelegateOnBehalf((bytes,bytes,bytes,uint256) p) returns()
func (_IPTokenStaking *IPTokenStakingTransactorSession) RedelegateOnBehalf(p IIPTokenStakingRedelegateParams) (*types.Transaction, error) {
	return _IPTokenStaking.Contract.RedelegateOnBehalf(&_IPTokenStaking.TransactOpts, p)
}

// RemoveOperator is a paid mutator transaction binding the contract method 0x17e42e12.
//
// Solidity: function removeOperator(bytes uncmpPubkey, address operator) returns()
func (_IPTokenStaking *IPTokenStakingTransactor) RemoveOperator(opts *bind.TransactOpts, uncmpPubkey []byte, operator common.Address) (*types.Transaction, error) {
	return _IPTokenStaking.contract.Transact(opts, "removeOperator", uncmpPubkey, operator)
}

// RemoveOperator is a paid mutator transaction binding the contract method 0x17e42e12.
//
// Solidity: function removeOperator(bytes uncmpPubkey, address operator) returns()
func (_IPTokenStaking *IPTokenStakingSession) RemoveOperator(uncmpPubkey []byte, operator common.Address) (*types.Transaction, error) {
	return _IPTokenStaking.Contract.RemoveOperator(&_IPTokenStaking.TransactOpts, uncmpPubkey, operator)
}

// RemoveOperator is a paid mutator transaction binding the contract method 0x17e42e12.
//
// Solidity: function removeOperator(bytes uncmpPubkey, address operator) returns()
func (_IPTokenStaking *IPTokenStakingTransactorSession) RemoveOperator(uncmpPubkey []byte, operator common.Address) (*types.Transaction, error) {
	return _IPTokenStaking.Contract.RemoveOperator(&_IPTokenStaking.TransactOpts, uncmpPubkey, operator)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_IPTokenStaking *IPTokenStakingTransactor) RenounceOwnership(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IPTokenStaking.contract.Transact(opts, "renounceOwnership")
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_IPTokenStaking *IPTokenStakingSession) RenounceOwnership() (*types.Transaction, error) {
	return _IPTokenStaking.Contract.RenounceOwnership(&_IPTokenStaking.TransactOpts)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_IPTokenStaking *IPTokenStakingTransactorSession) RenounceOwnership() (*types.Transaction, error) {
	return _IPTokenStaking.Contract.RenounceOwnership(&_IPTokenStaking.TransactOpts)
}

// SetMinRedelegateAmount is a paid mutator transaction binding the contract method 0x9855c8b5.
//
// Solidity: function setMinRedelegateAmount(uint256 newMinRedelegateAmount) returns()
func (_IPTokenStaking *IPTokenStakingTransactor) SetMinRedelegateAmount(opts *bind.TransactOpts, newMinRedelegateAmount *big.Int) (*types.Transaction, error) {
	return _IPTokenStaking.contract.Transact(opts, "setMinRedelegateAmount", newMinRedelegateAmount)
}

// SetMinRedelegateAmount is a paid mutator transaction binding the contract method 0x9855c8b5.
//
// Solidity: function setMinRedelegateAmount(uint256 newMinRedelegateAmount) returns()
func (_IPTokenStaking *IPTokenStakingSession) SetMinRedelegateAmount(newMinRedelegateAmount *big.Int) (*types.Transaction, error) {
	return _IPTokenStaking.Contract.SetMinRedelegateAmount(&_IPTokenStaking.TransactOpts, newMinRedelegateAmount)
}

// SetMinRedelegateAmount is a paid mutator transaction binding the contract method 0x9855c8b5.
//
// Solidity: function setMinRedelegateAmount(uint256 newMinRedelegateAmount) returns()
func (_IPTokenStaking *IPTokenStakingTransactorSession) SetMinRedelegateAmount(newMinRedelegateAmount *big.Int) (*types.Transaction, error) {
	return _IPTokenStaking.Contract.SetMinRedelegateAmount(&_IPTokenStaking.TransactOpts, newMinRedelegateAmount)
}

// SetMinStakeAmount is a paid mutator transaction binding the contract method 0xeb4af045.
//
// Solidity: function setMinStakeAmount(uint256 newMinStakeAmount) returns()
func (_IPTokenStaking *IPTokenStakingTransactor) SetMinStakeAmount(opts *bind.TransactOpts, newMinStakeAmount *big.Int) (*types.Transaction, error) {
	return _IPTokenStaking.contract.Transact(opts, "setMinStakeAmount", newMinStakeAmount)
}

// SetMinStakeAmount is a paid mutator transaction binding the contract method 0xeb4af045.
//
// Solidity: function setMinStakeAmount(uint256 newMinStakeAmount) returns()
func (_IPTokenStaking *IPTokenStakingSession) SetMinStakeAmount(newMinStakeAmount *big.Int) (*types.Transaction, error) {
	return _IPTokenStaking.Contract.SetMinStakeAmount(&_IPTokenStaking.TransactOpts, newMinStakeAmount)
}

// SetMinStakeAmount is a paid mutator transaction binding the contract method 0xeb4af045.
//
// Solidity: function setMinStakeAmount(uint256 newMinStakeAmount) returns()
func (_IPTokenStaking *IPTokenStakingTransactorSession) SetMinStakeAmount(newMinStakeAmount *big.Int) (*types.Transaction, error) {
	return _IPTokenStaking.Contract.SetMinStakeAmount(&_IPTokenStaking.TransactOpts, newMinStakeAmount)
}

// SetMinUnstakeAmount is a paid mutator transaction binding the contract method 0x6ea3a228.
//
// Solidity: function setMinUnstakeAmount(uint256 newMinUnstakeAmount) returns()
func (_IPTokenStaking *IPTokenStakingTransactor) SetMinUnstakeAmount(opts *bind.TransactOpts, newMinUnstakeAmount *big.Int) (*types.Transaction, error) {
	return _IPTokenStaking.contract.Transact(opts, "setMinUnstakeAmount", newMinUnstakeAmount)
}

// SetMinUnstakeAmount is a paid mutator transaction binding the contract method 0x6ea3a228.
//
// Solidity: function setMinUnstakeAmount(uint256 newMinUnstakeAmount) returns()
func (_IPTokenStaking *IPTokenStakingSession) SetMinUnstakeAmount(newMinUnstakeAmount *big.Int) (*types.Transaction, error) {
	return _IPTokenStaking.Contract.SetMinUnstakeAmount(&_IPTokenStaking.TransactOpts, newMinUnstakeAmount)
}

// SetMinUnstakeAmount is a paid mutator transaction binding the contract method 0x6ea3a228.
//
// Solidity: function setMinUnstakeAmount(uint256 newMinUnstakeAmount) returns()
func (_IPTokenStaking *IPTokenStakingTransactorSession) SetMinUnstakeAmount(newMinUnstakeAmount *big.Int) (*types.Transaction, error) {
	return _IPTokenStaking.Contract.SetMinUnstakeAmount(&_IPTokenStaking.TransactOpts, newMinUnstakeAmount)
}

// SetWithdrawalAddress is a paid mutator transaction binding the contract method 0x787f82c8.
//
// Solidity: function setWithdrawalAddress(bytes delegatorUncmpPubkey, address newWithdrawalAddress) returns()
func (_IPTokenStaking *IPTokenStakingTransactor) SetWithdrawalAddress(opts *bind.TransactOpts, delegatorUncmpPubkey []byte, newWithdrawalAddress common.Address) (*types.Transaction, error) {
	return _IPTokenStaking.contract.Transact(opts, "setWithdrawalAddress", delegatorUncmpPubkey, newWithdrawalAddress)
}

// SetWithdrawalAddress is a paid mutator transaction binding the contract method 0x787f82c8.
//
// Solidity: function setWithdrawalAddress(bytes delegatorUncmpPubkey, address newWithdrawalAddress) returns()
func (_IPTokenStaking *IPTokenStakingSession) SetWithdrawalAddress(delegatorUncmpPubkey []byte, newWithdrawalAddress common.Address) (*types.Transaction, error) {
	return _IPTokenStaking.Contract.SetWithdrawalAddress(&_IPTokenStaking.TransactOpts, delegatorUncmpPubkey, newWithdrawalAddress)
}

// SetWithdrawalAddress is a paid mutator transaction binding the contract method 0x787f82c8.
//
// Solidity: function setWithdrawalAddress(bytes delegatorUncmpPubkey, address newWithdrawalAddress) returns()
func (_IPTokenStaking *IPTokenStakingTransactorSession) SetWithdrawalAddress(delegatorUncmpPubkey []byte, newWithdrawalAddress common.Address) (*types.Transaction, error) {
	return _IPTokenStaking.Contract.SetWithdrawalAddress(&_IPTokenStaking.TransactOpts, delegatorUncmpPubkey, newWithdrawalAddress)
}

// SetWithdrawalAddressChangeInterval is a paid mutator transaction binding the contract method 0xeee5cead.
//
// Solidity: function setWithdrawalAddressChangeInterval(uint256 newWithdrawalAddressChangeInterval) returns()
func (_IPTokenStaking *IPTokenStakingTransactor) SetWithdrawalAddressChangeInterval(opts *bind.TransactOpts, newWithdrawalAddressChangeInterval *big.Int) (*types.Transaction, error) {
	return _IPTokenStaking.contract.Transact(opts, "setWithdrawalAddressChangeInterval", newWithdrawalAddressChangeInterval)
}

// SetWithdrawalAddressChangeInterval is a paid mutator transaction binding the contract method 0xeee5cead.
//
// Solidity: function setWithdrawalAddressChangeInterval(uint256 newWithdrawalAddressChangeInterval) returns()
func (_IPTokenStaking *IPTokenStakingSession) SetWithdrawalAddressChangeInterval(newWithdrawalAddressChangeInterval *big.Int) (*types.Transaction, error) {
	return _IPTokenStaking.Contract.SetWithdrawalAddressChangeInterval(&_IPTokenStaking.TransactOpts, newWithdrawalAddressChangeInterval)
}

// SetWithdrawalAddressChangeInterval is a paid mutator transaction binding the contract method 0xeee5cead.
//
// Solidity: function setWithdrawalAddressChangeInterval(uint256 newWithdrawalAddressChangeInterval) returns()
func (_IPTokenStaking *IPTokenStakingTransactorSession) SetWithdrawalAddressChangeInterval(newWithdrawalAddressChangeInterval *big.Int) (*types.Transaction, error) {
	return _IPTokenStaking.Contract.SetWithdrawalAddressChangeInterval(&_IPTokenStaking.TransactOpts, newWithdrawalAddressChangeInterval)
}

// Stake is a paid mutator transaction binding the contract method 0x86eec4a1.
//
// Solidity: function stake(bytes delegatorUncmpPubkey, bytes validatorCmpPubkey) payable returns()
func (_IPTokenStaking *IPTokenStakingTransactor) Stake(opts *bind.TransactOpts, delegatorUncmpPubkey []byte, validatorCmpPubkey []byte) (*types.Transaction, error) {
	return _IPTokenStaking.contract.Transact(opts, "stake", delegatorUncmpPubkey, validatorCmpPubkey)
}

// Stake is a paid mutator transaction binding the contract method 0x86eec4a1.
//
// Solidity: function stake(bytes delegatorUncmpPubkey, bytes validatorCmpPubkey) payable returns()
func (_IPTokenStaking *IPTokenStakingSession) Stake(delegatorUncmpPubkey []byte, validatorCmpPubkey []byte) (*types.Transaction, error) {
	return _IPTokenStaking.Contract.Stake(&_IPTokenStaking.TransactOpts, delegatorUncmpPubkey, validatorCmpPubkey)
}

// Stake is a paid mutator transaction binding the contract method 0x86eec4a1.
//
// Solidity: function stake(bytes delegatorUncmpPubkey, bytes validatorCmpPubkey) payable returns()
func (_IPTokenStaking *IPTokenStakingTransactorSession) Stake(delegatorUncmpPubkey []byte, validatorCmpPubkey []byte) (*types.Transaction, error) {
	return _IPTokenStaking.Contract.Stake(&_IPTokenStaking.TransactOpts, delegatorUncmpPubkey, validatorCmpPubkey)
}

// StakeOnBehalf is a paid mutator transaction binding the contract method 0x8f37ec19.
//
// Solidity: function stakeOnBehalf(bytes delegatorUncmpPubkey, bytes validatorCmpPubkey) payable returns()
func (_IPTokenStaking *IPTokenStakingTransactor) StakeOnBehalf(opts *bind.TransactOpts, delegatorUncmpPubkey []byte, validatorCmpPubkey []byte) (*types.Transaction, error) {
	return _IPTokenStaking.contract.Transact(opts, "stakeOnBehalf", delegatorUncmpPubkey, validatorCmpPubkey)
}

// StakeOnBehalf is a paid mutator transaction binding the contract method 0x8f37ec19.
//
// Solidity: function stakeOnBehalf(bytes delegatorUncmpPubkey, bytes validatorCmpPubkey) payable returns()
func (_IPTokenStaking *IPTokenStakingSession) StakeOnBehalf(delegatorUncmpPubkey []byte, validatorCmpPubkey []byte) (*types.Transaction, error) {
	return _IPTokenStaking.Contract.StakeOnBehalf(&_IPTokenStaking.TransactOpts, delegatorUncmpPubkey, validatorCmpPubkey)
}

// StakeOnBehalf is a paid mutator transaction binding the contract method 0x8f37ec19.
//
// Solidity: function stakeOnBehalf(bytes delegatorUncmpPubkey, bytes validatorCmpPubkey) payable returns()
func (_IPTokenStaking *IPTokenStakingTransactorSession) StakeOnBehalf(delegatorUncmpPubkey []byte, validatorCmpPubkey []byte) (*types.Transaction, error) {
	return _IPTokenStaking.Contract.StakeOnBehalf(&_IPTokenStaking.TransactOpts, delegatorUncmpPubkey, validatorCmpPubkey)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_IPTokenStaking *IPTokenStakingTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _IPTokenStaking.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_IPTokenStaking *IPTokenStakingSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _IPTokenStaking.Contract.TransferOwnership(&_IPTokenStaking.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_IPTokenStaking *IPTokenStakingTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _IPTokenStaking.Contract.TransferOwnership(&_IPTokenStaking.TransactOpts, newOwner)
}

// Unstake is a paid mutator transaction binding the contract method 0x5d5ab968.
//
// Solidity: function unstake(bytes delegatorUncmpPubkey, bytes validatorCmpPubkey, uint256 amount) returns()
func (_IPTokenStaking *IPTokenStakingTransactor) Unstake(opts *bind.TransactOpts, delegatorUncmpPubkey []byte, validatorCmpPubkey []byte, amount *big.Int) (*types.Transaction, error) {
	return _IPTokenStaking.contract.Transact(opts, "unstake", delegatorUncmpPubkey, validatorCmpPubkey, amount)
}

// Unstake is a paid mutator transaction binding the contract method 0x5d5ab968.
//
// Solidity: function unstake(bytes delegatorUncmpPubkey, bytes validatorCmpPubkey, uint256 amount) returns()
func (_IPTokenStaking *IPTokenStakingSession) Unstake(delegatorUncmpPubkey []byte, validatorCmpPubkey []byte, amount *big.Int) (*types.Transaction, error) {
	return _IPTokenStaking.Contract.Unstake(&_IPTokenStaking.TransactOpts, delegatorUncmpPubkey, validatorCmpPubkey, amount)
}

// Unstake is a paid mutator transaction binding the contract method 0x5d5ab968.
//
// Solidity: function unstake(bytes delegatorUncmpPubkey, bytes validatorCmpPubkey, uint256 amount) returns()
func (_IPTokenStaking *IPTokenStakingTransactorSession) Unstake(delegatorUncmpPubkey []byte, validatorCmpPubkey []byte, amount *big.Int) (*types.Transaction, error) {
	return _IPTokenStaking.Contract.Unstake(&_IPTokenStaking.TransactOpts, delegatorUncmpPubkey, validatorCmpPubkey, amount)
}

// UnstakeOnBehalf is a paid mutator transaction binding the contract method 0xa1cb1846.
//
// Solidity: function unstakeOnBehalf(bytes delegatorCmpPubkey, bytes validatorCmpPubkey, uint256 amount) returns()
func (_IPTokenStaking *IPTokenStakingTransactor) UnstakeOnBehalf(opts *bind.TransactOpts, delegatorCmpPubkey []byte, validatorCmpPubkey []byte, amount *big.Int) (*types.Transaction, error) {
	return _IPTokenStaking.contract.Transact(opts, "unstakeOnBehalf", delegatorCmpPubkey, validatorCmpPubkey, amount)
}

// UnstakeOnBehalf is a paid mutator transaction binding the contract method 0xa1cb1846.
//
// Solidity: function unstakeOnBehalf(bytes delegatorCmpPubkey, bytes validatorCmpPubkey, uint256 amount) returns()
func (_IPTokenStaking *IPTokenStakingSession) UnstakeOnBehalf(delegatorCmpPubkey []byte, validatorCmpPubkey []byte, amount *big.Int) (*types.Transaction, error) {
	return _IPTokenStaking.Contract.UnstakeOnBehalf(&_IPTokenStaking.TransactOpts, delegatorCmpPubkey, validatorCmpPubkey, amount)
}

// UnstakeOnBehalf is a paid mutator transaction binding the contract method 0xa1cb1846.
//
// Solidity: function unstakeOnBehalf(bytes delegatorCmpPubkey, bytes validatorCmpPubkey, uint256 amount) returns()
func (_IPTokenStaking *IPTokenStakingTransactorSession) UnstakeOnBehalf(delegatorCmpPubkey []byte, validatorCmpPubkey []byte, amount *big.Int) (*types.Transaction, error) {
	return _IPTokenStaking.Contract.UnstakeOnBehalf(&_IPTokenStaking.TransactOpts, delegatorCmpPubkey, validatorCmpPubkey, amount)
}

// UpgradeToAndCall is a paid mutator transaction binding the contract method 0x4f1ef286.
//
// Solidity: function upgradeToAndCall(address newImplementation, bytes data) payable returns()
func (_IPTokenStaking *IPTokenStakingTransactor) UpgradeToAndCall(opts *bind.TransactOpts, newImplementation common.Address, data []byte) (*types.Transaction, error) {
	return _IPTokenStaking.contract.Transact(opts, "upgradeToAndCall", newImplementation, data)
}

// UpgradeToAndCall is a paid mutator transaction binding the contract method 0x4f1ef286.
//
// Solidity: function upgradeToAndCall(address newImplementation, bytes data) payable returns()
func (_IPTokenStaking *IPTokenStakingSession) UpgradeToAndCall(newImplementation common.Address, data []byte) (*types.Transaction, error) {
	return _IPTokenStaking.Contract.UpgradeToAndCall(&_IPTokenStaking.TransactOpts, newImplementation, data)
}

// UpgradeToAndCall is a paid mutator transaction binding the contract method 0x4f1ef286.
//
// Solidity: function upgradeToAndCall(address newImplementation, bytes data) payable returns()
func (_IPTokenStaking *IPTokenStakingTransactorSession) UpgradeToAndCall(newImplementation common.Address, data []byte) (*types.Transaction, error) {
	return _IPTokenStaking.Contract.UpgradeToAndCall(&_IPTokenStaking.TransactOpts, newImplementation, data)
}

// IPTokenStakingCreateValidatorIterator is returned from FilterCreateValidator and is used to iterate over the raw logs and unpacked data for CreateValidator events raised by the IPTokenStaking contract.
type IPTokenStakingCreateValidatorIterator struct {
	Event *IPTokenStakingCreateValidator // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IPTokenStakingCreateValidatorIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IPTokenStakingCreateValidator)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IPTokenStakingCreateValidator)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IPTokenStakingCreateValidatorIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IPTokenStakingCreateValidatorIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IPTokenStakingCreateValidator represents a CreateValidator event raised by the IPTokenStaking contract.
type IPTokenStakingCreateValidator struct {
	ValidatorUncmpPubkey    []byte
	ValidatorCmpPubkey      []byte
	Moniker                 string
	StakeAmount             *big.Int
	CommissionRate          uint32
	MaxCommissionRate       uint32
	MaxCommissionChangeRate uint32
	Raw                     types.Log // Blockchain specific contextual infos
}

// FilterCreateValidator is a free log retrieval operation binding the contract event 0x86e28854e4d50fe7db57c8bede0c9deb5abf1e451982b19cc58742edef74459f.
//
// Solidity: event CreateValidator(bytes validatorUncmpPubkey, bytes validatorCmpPubkey, string moniker, uint256 stakeAmount, uint32 commissionRate, uint32 maxCommissionRate, uint32 maxCommissionChangeRate)
func (_IPTokenStaking *IPTokenStakingFilterer) FilterCreateValidator(opts *bind.FilterOpts) (*IPTokenStakingCreateValidatorIterator, error) {

	logs, sub, err := _IPTokenStaking.contract.FilterLogs(opts, "CreateValidator")
	if err != nil {
		return nil, err
	}
	return &IPTokenStakingCreateValidatorIterator{contract: _IPTokenStaking.contract, event: "CreateValidator", logs: logs, sub: sub}, nil
}

// WatchCreateValidator is a free log subscription operation binding the contract event 0x86e28854e4d50fe7db57c8bede0c9deb5abf1e451982b19cc58742edef74459f.
//
// Solidity: event CreateValidator(bytes validatorUncmpPubkey, bytes validatorCmpPubkey, string moniker, uint256 stakeAmount, uint32 commissionRate, uint32 maxCommissionRate, uint32 maxCommissionChangeRate)
func (_IPTokenStaking *IPTokenStakingFilterer) WatchCreateValidator(opts *bind.WatchOpts, sink chan<- *IPTokenStakingCreateValidator) (event.Subscription, error) {

	logs, sub, err := _IPTokenStaking.contract.WatchLogs(opts, "CreateValidator")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IPTokenStakingCreateValidator)
				if err := _IPTokenStaking.contract.UnpackLog(event, "CreateValidator", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseCreateValidator is a log parse operation binding the contract event 0x86e28854e4d50fe7db57c8bede0c9deb5abf1e451982b19cc58742edef74459f.
//
// Solidity: event CreateValidator(bytes validatorUncmpPubkey, bytes validatorCmpPubkey, string moniker, uint256 stakeAmount, uint32 commissionRate, uint32 maxCommissionRate, uint32 maxCommissionChangeRate)
func (_IPTokenStaking *IPTokenStakingFilterer) ParseCreateValidator(log types.Log) (*IPTokenStakingCreateValidator, error) {
	event := new(IPTokenStakingCreateValidator)
	if err := _IPTokenStaking.contract.UnpackLog(event, "CreateValidator", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IPTokenStakingDepositIterator is returned from FilterDeposit and is used to iterate over the raw logs and unpacked data for Deposit events raised by the IPTokenStaking contract.
type IPTokenStakingDepositIterator struct {
	Event *IPTokenStakingDeposit // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IPTokenStakingDepositIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IPTokenStakingDeposit)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IPTokenStakingDeposit)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IPTokenStakingDepositIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IPTokenStakingDepositIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IPTokenStakingDeposit represents a Deposit event raised by the IPTokenStaking contract.
type IPTokenStakingDeposit struct {
	DelegatorUncmpPubkey []byte
	DelegatorCmpPubkey   []byte
	ValidatorCmpPubkey   []byte
	Amount               *big.Int
	Raw                  types.Log // Blockchain specific contextual infos
}

// FilterDeposit is a free log retrieval operation binding the contract event 0x6f0ca1c9f1795cb6a6ba44d788bc09dfb45b3a223470ae03e049ee954f0829ed.
//
// Solidity: event Deposit(bytes delegatorUncmpPubkey, bytes delegatorCmpPubkey, bytes validatorCmpPubkey, uint256 amount)
func (_IPTokenStaking *IPTokenStakingFilterer) FilterDeposit(opts *bind.FilterOpts) (*IPTokenStakingDepositIterator, error) {

	logs, sub, err := _IPTokenStaking.contract.FilterLogs(opts, "Deposit")
	if err != nil {
		return nil, err
	}
	return &IPTokenStakingDepositIterator{contract: _IPTokenStaking.contract, event: "Deposit", logs: logs, sub: sub}, nil
}

// WatchDeposit is a free log subscription operation binding the contract event 0x6f0ca1c9f1795cb6a6ba44d788bc09dfb45b3a223470ae03e049ee954f0829ed.
//
// Solidity: event Deposit(bytes delegatorUncmpPubkey, bytes delegatorCmpPubkey, bytes validatorCmpPubkey, uint256 amount)
func (_IPTokenStaking *IPTokenStakingFilterer) WatchDeposit(opts *bind.WatchOpts, sink chan<- *IPTokenStakingDeposit) (event.Subscription, error) {

	logs, sub, err := _IPTokenStaking.contract.WatchLogs(opts, "Deposit")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IPTokenStakingDeposit)
				if err := _IPTokenStaking.contract.UnpackLog(event, "Deposit", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDeposit is a log parse operation binding the contract event 0x6f0ca1c9f1795cb6a6ba44d788bc09dfb45b3a223470ae03e049ee954f0829ed.
//
// Solidity: event Deposit(bytes delegatorUncmpPubkey, bytes delegatorCmpPubkey, bytes validatorCmpPubkey, uint256 amount)
func (_IPTokenStaking *IPTokenStakingFilterer) ParseDeposit(log types.Log) (*IPTokenStakingDeposit, error) {
	event := new(IPTokenStakingDeposit)
	if err := _IPTokenStaking.contract.UnpackLog(event, "Deposit", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IPTokenStakingInitializedIterator is returned from FilterInitialized and is used to iterate over the raw logs and unpacked data for Initialized events raised by the IPTokenStaking contract.
type IPTokenStakingInitializedIterator struct {
	Event *IPTokenStakingInitialized // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IPTokenStakingInitializedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IPTokenStakingInitialized)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IPTokenStakingInitialized)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IPTokenStakingInitializedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IPTokenStakingInitializedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IPTokenStakingInitialized represents a Initialized event raised by the IPTokenStaking contract.
type IPTokenStakingInitialized struct {
	Version uint64
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterInitialized is a free log retrieval operation binding the contract event 0xc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d2.
//
// Solidity: event Initialized(uint64 version)
func (_IPTokenStaking *IPTokenStakingFilterer) FilterInitialized(opts *bind.FilterOpts) (*IPTokenStakingInitializedIterator, error) {

	logs, sub, err := _IPTokenStaking.contract.FilterLogs(opts, "Initialized")
	if err != nil {
		return nil, err
	}
	return &IPTokenStakingInitializedIterator{contract: _IPTokenStaking.contract, event: "Initialized", logs: logs, sub: sub}, nil
}

// WatchInitialized is a free log subscription operation binding the contract event 0xc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d2.
//
// Solidity: event Initialized(uint64 version)
func (_IPTokenStaking *IPTokenStakingFilterer) WatchInitialized(opts *bind.WatchOpts, sink chan<- *IPTokenStakingInitialized) (event.Subscription, error) {

	logs, sub, err := _IPTokenStaking.contract.WatchLogs(opts, "Initialized")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IPTokenStakingInitialized)
				if err := _IPTokenStaking.contract.UnpackLog(event, "Initialized", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseInitialized is a log parse operation binding the contract event 0xc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d2.
//
// Solidity: event Initialized(uint64 version)
func (_IPTokenStaking *IPTokenStakingFilterer) ParseInitialized(log types.Log) (*IPTokenStakingInitialized, error) {
	event := new(IPTokenStakingInitialized)
	if err := _IPTokenStaking.contract.UnpackLog(event, "Initialized", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IPTokenStakingMinRedelegateAmountSetIterator is returned from FilterMinRedelegateAmountSet and is used to iterate over the raw logs and unpacked data for MinRedelegateAmountSet events raised by the IPTokenStaking contract.
type IPTokenStakingMinRedelegateAmountSetIterator struct {
	Event *IPTokenStakingMinRedelegateAmountSet // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IPTokenStakingMinRedelegateAmountSetIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IPTokenStakingMinRedelegateAmountSet)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IPTokenStakingMinRedelegateAmountSet)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IPTokenStakingMinRedelegateAmountSetIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IPTokenStakingMinRedelegateAmountSetIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IPTokenStakingMinRedelegateAmountSet represents a MinRedelegateAmountSet event raised by the IPTokenStaking contract.
type IPTokenStakingMinRedelegateAmountSet struct {
	MinRedelegateAmount *big.Int
	Raw                 types.Log // Blockchain specific contextual infos
}

// FilterMinRedelegateAmountSet is a free log retrieval operation binding the contract event 0xf1e15ded5b5192ec1a89a3d16f49c46c7fa6c876d1f8299cf036f5abf9924d9b.
//
// Solidity: event MinRedelegateAmountSet(uint256 minRedelegateAmount)
func (_IPTokenStaking *IPTokenStakingFilterer) FilterMinRedelegateAmountSet(opts *bind.FilterOpts) (*IPTokenStakingMinRedelegateAmountSetIterator, error) {

	logs, sub, err := _IPTokenStaking.contract.FilterLogs(opts, "MinRedelegateAmountSet")
	if err != nil {
		return nil, err
	}
	return &IPTokenStakingMinRedelegateAmountSetIterator{contract: _IPTokenStaking.contract, event: "MinRedelegateAmountSet", logs: logs, sub: sub}, nil
}

// WatchMinRedelegateAmountSet is a free log subscription operation binding the contract event 0xf1e15ded5b5192ec1a89a3d16f49c46c7fa6c876d1f8299cf036f5abf9924d9b.
//
// Solidity: event MinRedelegateAmountSet(uint256 minRedelegateAmount)
func (_IPTokenStaking *IPTokenStakingFilterer) WatchMinRedelegateAmountSet(opts *bind.WatchOpts, sink chan<- *IPTokenStakingMinRedelegateAmountSet) (event.Subscription, error) {

	logs, sub, err := _IPTokenStaking.contract.WatchLogs(opts, "MinRedelegateAmountSet")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IPTokenStakingMinRedelegateAmountSet)
				if err := _IPTokenStaking.contract.UnpackLog(event, "MinRedelegateAmountSet", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseMinRedelegateAmountSet is a log parse operation binding the contract event 0xf1e15ded5b5192ec1a89a3d16f49c46c7fa6c876d1f8299cf036f5abf9924d9b.
//
// Solidity: event MinRedelegateAmountSet(uint256 minRedelegateAmount)
func (_IPTokenStaking *IPTokenStakingFilterer) ParseMinRedelegateAmountSet(log types.Log) (*IPTokenStakingMinRedelegateAmountSet, error) {
	event := new(IPTokenStakingMinRedelegateAmountSet)
	if err := _IPTokenStaking.contract.UnpackLog(event, "MinRedelegateAmountSet", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IPTokenStakingMinStakeAmountSetIterator is returned from FilterMinStakeAmountSet and is used to iterate over the raw logs and unpacked data for MinStakeAmountSet events raised by the IPTokenStaking contract.
type IPTokenStakingMinStakeAmountSetIterator struct {
	Event *IPTokenStakingMinStakeAmountSet // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IPTokenStakingMinStakeAmountSetIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IPTokenStakingMinStakeAmountSet)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IPTokenStakingMinStakeAmountSet)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IPTokenStakingMinStakeAmountSetIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IPTokenStakingMinStakeAmountSetIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IPTokenStakingMinStakeAmountSet represents a MinStakeAmountSet event raised by the IPTokenStaking contract.
type IPTokenStakingMinStakeAmountSet struct {
	MinStakeAmount *big.Int
	Raw            types.Log // Blockchain specific contextual infos
}

// FilterMinStakeAmountSet is a free log retrieval operation binding the contract event 0xea095c2fea861b87f0fd54d0d4453358692a527e120df22b62c71696247dfb9f.
//
// Solidity: event MinStakeAmountSet(uint256 minStakeAmount)
func (_IPTokenStaking *IPTokenStakingFilterer) FilterMinStakeAmountSet(opts *bind.FilterOpts) (*IPTokenStakingMinStakeAmountSetIterator, error) {

	logs, sub, err := _IPTokenStaking.contract.FilterLogs(opts, "MinStakeAmountSet")
	if err != nil {
		return nil, err
	}
	return &IPTokenStakingMinStakeAmountSetIterator{contract: _IPTokenStaking.contract, event: "MinStakeAmountSet", logs: logs, sub: sub}, nil
}

// WatchMinStakeAmountSet is a free log subscription operation binding the contract event 0xea095c2fea861b87f0fd54d0d4453358692a527e120df22b62c71696247dfb9f.
//
// Solidity: event MinStakeAmountSet(uint256 minStakeAmount)
func (_IPTokenStaking *IPTokenStakingFilterer) WatchMinStakeAmountSet(opts *bind.WatchOpts, sink chan<- *IPTokenStakingMinStakeAmountSet) (event.Subscription, error) {

	logs, sub, err := _IPTokenStaking.contract.WatchLogs(opts, "MinStakeAmountSet")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IPTokenStakingMinStakeAmountSet)
				if err := _IPTokenStaking.contract.UnpackLog(event, "MinStakeAmountSet", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseMinStakeAmountSet is a log parse operation binding the contract event 0xea095c2fea861b87f0fd54d0d4453358692a527e120df22b62c71696247dfb9f.
//
// Solidity: event MinStakeAmountSet(uint256 minStakeAmount)
func (_IPTokenStaking *IPTokenStakingFilterer) ParseMinStakeAmountSet(log types.Log) (*IPTokenStakingMinStakeAmountSet, error) {
	event := new(IPTokenStakingMinStakeAmountSet)
	if err := _IPTokenStaking.contract.UnpackLog(event, "MinStakeAmountSet", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IPTokenStakingMinUnstakeAmountSetIterator is returned from FilterMinUnstakeAmountSet and is used to iterate over the raw logs and unpacked data for MinUnstakeAmountSet events raised by the IPTokenStaking contract.
type IPTokenStakingMinUnstakeAmountSetIterator struct {
	Event *IPTokenStakingMinUnstakeAmountSet // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IPTokenStakingMinUnstakeAmountSetIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IPTokenStakingMinUnstakeAmountSet)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IPTokenStakingMinUnstakeAmountSet)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IPTokenStakingMinUnstakeAmountSetIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IPTokenStakingMinUnstakeAmountSetIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IPTokenStakingMinUnstakeAmountSet represents a MinUnstakeAmountSet event raised by the IPTokenStaking contract.
type IPTokenStakingMinUnstakeAmountSet struct {
	MinUnstakeAmount *big.Int
	Raw              types.Log // Blockchain specific contextual infos
}

// FilterMinUnstakeAmountSet is a free log retrieval operation binding the contract event 0xf93d77980ae5a1ddd008d6a7f02cbee5af2a4fcea850c4b55828de4f644e589f.
//
// Solidity: event MinUnstakeAmountSet(uint256 minUnstakeAmount)
func (_IPTokenStaking *IPTokenStakingFilterer) FilterMinUnstakeAmountSet(opts *bind.FilterOpts) (*IPTokenStakingMinUnstakeAmountSetIterator, error) {

	logs, sub, err := _IPTokenStaking.contract.FilterLogs(opts, "MinUnstakeAmountSet")
	if err != nil {
		return nil, err
	}
	return &IPTokenStakingMinUnstakeAmountSetIterator{contract: _IPTokenStaking.contract, event: "MinUnstakeAmountSet", logs: logs, sub: sub}, nil
}

// WatchMinUnstakeAmountSet is a free log subscription operation binding the contract event 0xf93d77980ae5a1ddd008d6a7f02cbee5af2a4fcea850c4b55828de4f644e589f.
//
// Solidity: event MinUnstakeAmountSet(uint256 minUnstakeAmount)
func (_IPTokenStaking *IPTokenStakingFilterer) WatchMinUnstakeAmountSet(opts *bind.WatchOpts, sink chan<- *IPTokenStakingMinUnstakeAmountSet) (event.Subscription, error) {

	logs, sub, err := _IPTokenStaking.contract.WatchLogs(opts, "MinUnstakeAmountSet")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IPTokenStakingMinUnstakeAmountSet)
				if err := _IPTokenStaking.contract.UnpackLog(event, "MinUnstakeAmountSet", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseMinUnstakeAmountSet is a log parse operation binding the contract event 0xf93d77980ae5a1ddd008d6a7f02cbee5af2a4fcea850c4b55828de4f644e589f.
//
// Solidity: event MinUnstakeAmountSet(uint256 minUnstakeAmount)
func (_IPTokenStaking *IPTokenStakingFilterer) ParseMinUnstakeAmountSet(log types.Log) (*IPTokenStakingMinUnstakeAmountSet, error) {
	event := new(IPTokenStakingMinUnstakeAmountSet)
	if err := _IPTokenStaking.contract.UnpackLog(event, "MinUnstakeAmountSet", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IPTokenStakingOwnershipTransferStartedIterator is returned from FilterOwnershipTransferStarted and is used to iterate over the raw logs and unpacked data for OwnershipTransferStarted events raised by the IPTokenStaking contract.
type IPTokenStakingOwnershipTransferStartedIterator struct {
	Event *IPTokenStakingOwnershipTransferStarted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IPTokenStakingOwnershipTransferStartedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IPTokenStakingOwnershipTransferStarted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IPTokenStakingOwnershipTransferStarted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IPTokenStakingOwnershipTransferStartedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IPTokenStakingOwnershipTransferStartedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IPTokenStakingOwnershipTransferStarted represents a OwnershipTransferStarted event raised by the IPTokenStaking contract.
type IPTokenStakingOwnershipTransferStarted struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferStarted is a free log retrieval operation binding the contract event 0x38d16b8cac22d99fc7c124b9cd0de2d3fa1faef420bfe791d8c362d765e22700.
//
// Solidity: event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner)
func (_IPTokenStaking *IPTokenStakingFilterer) FilterOwnershipTransferStarted(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*IPTokenStakingOwnershipTransferStartedIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _IPTokenStaking.contract.FilterLogs(opts, "OwnershipTransferStarted", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &IPTokenStakingOwnershipTransferStartedIterator{contract: _IPTokenStaking.contract, event: "OwnershipTransferStarted", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferStarted is a free log subscription operation binding the contract event 0x38d16b8cac22d99fc7c124b9cd0de2d3fa1faef420bfe791d8c362d765e22700.
//
// Solidity: event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner)
func (_IPTokenStaking *IPTokenStakingFilterer) WatchOwnershipTransferStarted(opts *bind.WatchOpts, sink chan<- *IPTokenStakingOwnershipTransferStarted, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _IPTokenStaking.contract.WatchLogs(opts, "OwnershipTransferStarted", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IPTokenStakingOwnershipTransferStarted)
				if err := _IPTokenStaking.contract.UnpackLog(event, "OwnershipTransferStarted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferStarted is a log parse operation binding the contract event 0x38d16b8cac22d99fc7c124b9cd0de2d3fa1faef420bfe791d8c362d765e22700.
//
// Solidity: event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner)
func (_IPTokenStaking *IPTokenStakingFilterer) ParseOwnershipTransferStarted(log types.Log) (*IPTokenStakingOwnershipTransferStarted, error) {
	event := new(IPTokenStakingOwnershipTransferStarted)
	if err := _IPTokenStaking.contract.UnpackLog(event, "OwnershipTransferStarted", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IPTokenStakingOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the IPTokenStaking contract.
type IPTokenStakingOwnershipTransferredIterator struct {
	Event *IPTokenStakingOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IPTokenStakingOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IPTokenStakingOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IPTokenStakingOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IPTokenStakingOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IPTokenStakingOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IPTokenStakingOwnershipTransferred represents a OwnershipTransferred event raised by the IPTokenStaking contract.
type IPTokenStakingOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_IPTokenStaking *IPTokenStakingFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*IPTokenStakingOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _IPTokenStaking.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &IPTokenStakingOwnershipTransferredIterator{contract: _IPTokenStaking.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_IPTokenStaking *IPTokenStakingFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *IPTokenStakingOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _IPTokenStaking.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IPTokenStakingOwnershipTransferred)
				if err := _IPTokenStaking.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_IPTokenStaking *IPTokenStakingFilterer) ParseOwnershipTransferred(log types.Log) (*IPTokenStakingOwnershipTransferred, error) {
	event := new(IPTokenStakingOwnershipTransferred)
	if err := _IPTokenStaking.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IPTokenStakingRedelegateIterator is returned from FilterRedelegate and is used to iterate over the raw logs and unpacked data for Redelegate events raised by the IPTokenStaking contract.
type IPTokenStakingRedelegateIterator struct {
	Event *IPTokenStakingRedelegate // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IPTokenStakingRedelegateIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IPTokenStakingRedelegate)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IPTokenStakingRedelegate)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IPTokenStakingRedelegateIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IPTokenStakingRedelegateIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IPTokenStakingRedelegate represents a Redelegate event raised by the IPTokenStaking contract.
type IPTokenStakingRedelegate struct {
	DelegatorCmpPubkey []byte
	ValidatorSrcPubkey []byte
	ValidatorDstPubkey []byte
	Amount             *big.Int
	Raw                types.Log // Blockchain specific contextual infos
}

// FilterRedelegate is a free log retrieval operation binding the contract event 0xb025fa2a574dd306182c6ac63bf7b05482b99680c1b38a42d8401a0adfd3775a.
//
// Solidity: event Redelegate(bytes delegatorCmpPubkey, bytes validatorSrcPubkey, bytes validatorDstPubkey, uint256 amount)
func (_IPTokenStaking *IPTokenStakingFilterer) FilterRedelegate(opts *bind.FilterOpts) (*IPTokenStakingRedelegateIterator, error) {

	logs, sub, err := _IPTokenStaking.contract.FilterLogs(opts, "Redelegate")
	if err != nil {
		return nil, err
	}
	return &IPTokenStakingRedelegateIterator{contract: _IPTokenStaking.contract, event: "Redelegate", logs: logs, sub: sub}, nil
}

// WatchRedelegate is a free log subscription operation binding the contract event 0xb025fa2a574dd306182c6ac63bf7b05482b99680c1b38a42d8401a0adfd3775a.
//
// Solidity: event Redelegate(bytes delegatorCmpPubkey, bytes validatorSrcPubkey, bytes validatorDstPubkey, uint256 amount)
func (_IPTokenStaking *IPTokenStakingFilterer) WatchRedelegate(opts *bind.WatchOpts, sink chan<- *IPTokenStakingRedelegate) (event.Subscription, error) {

	logs, sub, err := _IPTokenStaking.contract.WatchLogs(opts, "Redelegate")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IPTokenStakingRedelegate)
				if err := _IPTokenStaking.contract.UnpackLog(event, "Redelegate", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRedelegate is a log parse operation binding the contract event 0xb025fa2a574dd306182c6ac63bf7b05482b99680c1b38a42d8401a0adfd3775a.
//
// Solidity: event Redelegate(bytes delegatorCmpPubkey, bytes validatorSrcPubkey, bytes validatorDstPubkey, uint256 amount)
func (_IPTokenStaking *IPTokenStakingFilterer) ParseRedelegate(log types.Log) (*IPTokenStakingRedelegate, error) {
	event := new(IPTokenStakingRedelegate)
	if err := _IPTokenStaking.contract.UnpackLog(event, "Redelegate", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IPTokenStakingSetWithdrawalAddressIterator is returned from FilterSetWithdrawalAddress and is used to iterate over the raw logs and unpacked data for SetWithdrawalAddress events raised by the IPTokenStaking contract.
type IPTokenStakingSetWithdrawalAddressIterator struct {
	Event *IPTokenStakingSetWithdrawalAddress // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IPTokenStakingSetWithdrawalAddressIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IPTokenStakingSetWithdrawalAddress)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IPTokenStakingSetWithdrawalAddress)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IPTokenStakingSetWithdrawalAddressIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IPTokenStakingSetWithdrawalAddressIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IPTokenStakingSetWithdrawalAddress represents a SetWithdrawalAddress event raised by the IPTokenStaking contract.
type IPTokenStakingSetWithdrawalAddress struct {
	DelegatorCmpPubkey []byte
	ExecutionAddress   [32]byte
	Raw                types.Log // Blockchain specific contextual infos
}

// FilterSetWithdrawalAddress is a free log retrieval operation binding the contract event 0x9f7f04f688298f474ed4c786abb29e0ca0173d70516d55d9eac515609b45fbca.
//
// Solidity: event SetWithdrawalAddress(bytes delegatorCmpPubkey, bytes32 executionAddress)
func (_IPTokenStaking *IPTokenStakingFilterer) FilterSetWithdrawalAddress(opts *bind.FilterOpts) (*IPTokenStakingSetWithdrawalAddressIterator, error) {

	logs, sub, err := _IPTokenStaking.contract.FilterLogs(opts, "SetWithdrawalAddress")
	if err != nil {
		return nil, err
	}
	return &IPTokenStakingSetWithdrawalAddressIterator{contract: _IPTokenStaking.contract, event: "SetWithdrawalAddress", logs: logs, sub: sub}, nil
}

// WatchSetWithdrawalAddress is a free log subscription operation binding the contract event 0x9f7f04f688298f474ed4c786abb29e0ca0173d70516d55d9eac515609b45fbca.
//
// Solidity: event SetWithdrawalAddress(bytes delegatorCmpPubkey, bytes32 executionAddress)
func (_IPTokenStaking *IPTokenStakingFilterer) WatchSetWithdrawalAddress(opts *bind.WatchOpts, sink chan<- *IPTokenStakingSetWithdrawalAddress) (event.Subscription, error) {

	logs, sub, err := _IPTokenStaking.contract.WatchLogs(opts, "SetWithdrawalAddress")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IPTokenStakingSetWithdrawalAddress)
				if err := _IPTokenStaking.contract.UnpackLog(event, "SetWithdrawalAddress", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSetWithdrawalAddress is a log parse operation binding the contract event 0x9f7f04f688298f474ed4c786abb29e0ca0173d70516d55d9eac515609b45fbca.
//
// Solidity: event SetWithdrawalAddress(bytes delegatorCmpPubkey, bytes32 executionAddress)
func (_IPTokenStaking *IPTokenStakingFilterer) ParseSetWithdrawalAddress(log types.Log) (*IPTokenStakingSetWithdrawalAddress, error) {
	event := new(IPTokenStakingSetWithdrawalAddress)
	if err := _IPTokenStaking.contract.UnpackLog(event, "SetWithdrawalAddress", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IPTokenStakingUpgradedIterator is returned from FilterUpgraded and is used to iterate over the raw logs and unpacked data for Upgraded events raised by the IPTokenStaking contract.
type IPTokenStakingUpgradedIterator struct {
	Event *IPTokenStakingUpgraded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IPTokenStakingUpgradedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IPTokenStakingUpgraded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IPTokenStakingUpgraded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IPTokenStakingUpgradedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IPTokenStakingUpgradedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IPTokenStakingUpgraded represents a Upgraded event raised by the IPTokenStaking contract.
type IPTokenStakingUpgraded struct {
	Implementation common.Address
	Raw            types.Log // Blockchain specific contextual infos
}

// FilterUpgraded is a free log retrieval operation binding the contract event 0xbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b.
//
// Solidity: event Upgraded(address indexed implementation)
func (_IPTokenStaking *IPTokenStakingFilterer) FilterUpgraded(opts *bind.FilterOpts, implementation []common.Address) (*IPTokenStakingUpgradedIterator, error) {

	var implementationRule []interface{}
	for _, implementationItem := range implementation {
		implementationRule = append(implementationRule, implementationItem)
	}

	logs, sub, err := _IPTokenStaking.contract.FilterLogs(opts, "Upgraded", implementationRule)
	if err != nil {
		return nil, err
	}
	return &IPTokenStakingUpgradedIterator{contract: _IPTokenStaking.contract, event: "Upgraded", logs: logs, sub: sub}, nil
}

// WatchUpgraded is a free log subscription operation binding the contract event 0xbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b.
//
// Solidity: event Upgraded(address indexed implementation)
func (_IPTokenStaking *IPTokenStakingFilterer) WatchUpgraded(opts *bind.WatchOpts, sink chan<- *IPTokenStakingUpgraded, implementation []common.Address) (event.Subscription, error) {

	var implementationRule []interface{}
	for _, implementationItem := range implementation {
		implementationRule = append(implementationRule, implementationItem)
	}

	logs, sub, err := _IPTokenStaking.contract.WatchLogs(opts, "Upgraded", implementationRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IPTokenStakingUpgraded)
				if err := _IPTokenStaking.contract.UnpackLog(event, "Upgraded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUpgraded is a log parse operation binding the contract event 0xbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b.
//
// Solidity: event Upgraded(address indexed implementation)
func (_IPTokenStaking *IPTokenStakingFilterer) ParseUpgraded(log types.Log) (*IPTokenStakingUpgraded, error) {
	event := new(IPTokenStakingUpgraded)
	if err := _IPTokenStaking.contract.UnpackLog(event, "Upgraded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IPTokenStakingWithdrawIterator is returned from FilterWithdraw and is used to iterate over the raw logs and unpacked data for Withdraw events raised by the IPTokenStaking contract.
type IPTokenStakingWithdrawIterator struct {
	Event *IPTokenStakingWithdraw // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IPTokenStakingWithdrawIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IPTokenStakingWithdraw)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IPTokenStakingWithdraw)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IPTokenStakingWithdrawIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IPTokenStakingWithdrawIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IPTokenStakingWithdraw represents a Withdraw event raised by the IPTokenStaking contract.
type IPTokenStakingWithdraw struct {
	DelegatorCmpPubkey []byte
	ValidatorCmpPubkey []byte
	Amount             *big.Int
	Raw                types.Log // Blockchain specific contextual infos
}

// FilterWithdraw is a free log retrieval operation binding the contract event 0x0526a04a9b113a046b17e2350e42123a2515b5558b3aea91576ccdb1270c1b59.
//
// Solidity: event Withdraw(bytes delegatorCmpPubkey, bytes validatorCmpPubkey, uint256 amount)
func (_IPTokenStaking *IPTokenStakingFilterer) FilterWithdraw(opts *bind.FilterOpts) (*IPTokenStakingWithdrawIterator, error) {

	logs, sub, err := _IPTokenStaking.contract.FilterLogs(opts, "Withdraw")
	if err != nil {
		return nil, err
	}
	return &IPTokenStakingWithdrawIterator{contract: _IPTokenStaking.contract, event: "Withdraw", logs: logs, sub: sub}, nil
}

// WatchWithdraw is a free log subscription operation binding the contract event 0x0526a04a9b113a046b17e2350e42123a2515b5558b3aea91576ccdb1270c1b59.
//
// Solidity: event Withdraw(bytes delegatorCmpPubkey, bytes validatorCmpPubkey, uint256 amount)
func (_IPTokenStaking *IPTokenStakingFilterer) WatchWithdraw(opts *bind.WatchOpts, sink chan<- *IPTokenStakingWithdraw) (event.Subscription, error) {

	logs, sub, err := _IPTokenStaking.contract.WatchLogs(opts, "Withdraw")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IPTokenStakingWithdraw)
				if err := _IPTokenStaking.contract.UnpackLog(event, "Withdraw", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseWithdraw is a log parse operation binding the contract event 0x0526a04a9b113a046b17e2350e42123a2515b5558b3aea91576ccdb1270c1b59.
//
// Solidity: event Withdraw(bytes delegatorCmpPubkey, bytes validatorCmpPubkey, uint256 amount)
func (_IPTokenStaking *IPTokenStakingFilterer) ParseWithdraw(log types.Log) (*IPTokenStakingWithdraw, error) {
	event := new(IPTokenStakingWithdraw)
	if err := _IPTokenStaking.contract.UnpackLog(event, "Withdraw", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IPTokenStakingWithdrawalAddressChangeIntervalSetIterator is returned from FilterWithdrawalAddressChangeIntervalSet and is used to iterate over the raw logs and unpacked data for WithdrawalAddressChangeIntervalSet events raised by the IPTokenStaking contract.
type IPTokenStakingWithdrawalAddressChangeIntervalSetIterator struct {
	Event *IPTokenStakingWithdrawalAddressChangeIntervalSet // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IPTokenStakingWithdrawalAddressChangeIntervalSetIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IPTokenStakingWithdrawalAddressChangeIntervalSet)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IPTokenStakingWithdrawalAddressChangeIntervalSet)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IPTokenStakingWithdrawalAddressChangeIntervalSetIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IPTokenStakingWithdrawalAddressChangeIntervalSetIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IPTokenStakingWithdrawalAddressChangeIntervalSet represents a WithdrawalAddressChangeIntervalSet event raised by the IPTokenStaking contract.
type IPTokenStakingWithdrawalAddressChangeIntervalSet struct {
	NewInterval *big.Int
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterWithdrawalAddressChangeIntervalSet is a free log retrieval operation binding the contract event 0xbed33ba1e6aacc702f8e48397b388e43ca92a8898ed8bdb389fd8b18af95d32c.
//
// Solidity: event WithdrawalAddressChangeIntervalSet(uint256 newInterval)
func (_IPTokenStaking *IPTokenStakingFilterer) FilterWithdrawalAddressChangeIntervalSet(opts *bind.FilterOpts) (*IPTokenStakingWithdrawalAddressChangeIntervalSetIterator, error) {

	logs, sub, err := _IPTokenStaking.contract.FilterLogs(opts, "WithdrawalAddressChangeIntervalSet")
	if err != nil {
		return nil, err
	}
	return &IPTokenStakingWithdrawalAddressChangeIntervalSetIterator{contract: _IPTokenStaking.contract, event: "WithdrawalAddressChangeIntervalSet", logs: logs, sub: sub}, nil
}

// WatchWithdrawalAddressChangeIntervalSet is a free log subscription operation binding the contract event 0xbed33ba1e6aacc702f8e48397b388e43ca92a8898ed8bdb389fd8b18af95d32c.
//
// Solidity: event WithdrawalAddressChangeIntervalSet(uint256 newInterval)
func (_IPTokenStaking *IPTokenStakingFilterer) WatchWithdrawalAddressChangeIntervalSet(opts *bind.WatchOpts, sink chan<- *IPTokenStakingWithdrawalAddressChangeIntervalSet) (event.Subscription, error) {

	logs, sub, err := _IPTokenStaking.contract.WatchLogs(opts, "WithdrawalAddressChangeIntervalSet")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IPTokenStakingWithdrawalAddressChangeIntervalSet)
				if err := _IPTokenStaking.contract.UnpackLog(event, "WithdrawalAddressChangeIntervalSet", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseWithdrawalAddressChangeIntervalSet is a log parse operation binding the contract event 0xbed33ba1e6aacc702f8e48397b388e43ca92a8898ed8bdb389fd8b18af95d32c.
//
// Solidity: event WithdrawalAddressChangeIntervalSet(uint256 newInterval)
func (_IPTokenStaking *IPTokenStakingFilterer) ParseWithdrawalAddressChangeIntervalSet(log types.Log) (*IPTokenStakingWithdrawalAddressChangeIntervalSet, error) {
	event := new(IPTokenStakingWithdrawalAddressChangeIntervalSet)
	if err := _IPTokenStaking.contract.UnpackLog(event, "WithdrawalAddressChangeIntervalSet", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}
